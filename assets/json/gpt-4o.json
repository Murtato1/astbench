[
    {
        "notebook": {
            "assignment": "01_EmLineGalaxies_SpectraStack_assignment.ipynb",
            "reference": "/Users/saj2765/Desktop/astro/rare-packages-code-gen/notebook_analysis/notebooks-latest/03_ScienceExamples/EmLineGalaxies/01_EmLineGalaxies_SpectraStack.ipynb",
            "prefix": "emlinegalaxies_0"
        },
        "model": {
            "model": "gpt-4o",
            "library": "OA"
        },
        "result": [
            {
                "ind": 2,
                "gen_code": "# Initialization metadata\nNOTEBOOK_ID = \"Spectra_Stacking_SDSS\"\nAUTHOR = \"Your Name\"\nVERSION = \"1.0\"\nDATASETS = [\"sdss_dr12\", \"sdss_dr16\"]",
                "true_code": "__nbid__ = '0011'\n__author__ = 'Ragadeepika Pucha <rpucha@arizona.edu>, Stephanie Juneau <stephanie.juneau@noirlab.edu>'\n__version__ = '20240603' # yyyymmdd\n__datasets__ = ['sdss_dr12', 'sdss_dr16']\n__keywords__ = ['sdss spectra', 'spectra stacking', 'sparcl']",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 23,
                "codebleu": {
                    "codebleu": 0.3804553050913528,
                    "ngram_match_score": 0.00955164359596683,
                    "weighted_ngram_match_score": 0.010438074937942448,
                    "syntax_match_score": 0.8095238095238095,
                    "dataflow_match_score": 0.6923076923076923
                },
                "codebertscore": {
                    "precision": 0.7672663927078247,
                    "recall": 0.7037336826324463,
                    "F1": 0.7341280579566956,
                    "F3": 0.7096095085144043
                },
                "codebertscore_rescaled": {
                    "precision": 0.5345327854156494,
                    "recall": 0.4074673652648926,
                    "F1": 0.4682561159133911,
                    "F3": 0.4192190170288086
                }
            },
            {
                "ind": 12,
                "gen_code": "# Uncomment the lines below to enable authentication.\n# user = getpass('Enter your user name: ')\n# pw = getpass('Enter your password: ')\n# token = ac.login(user, pw)",
                "true_code": "#token = ac.login(input(\"Enter user name: (+ENTER) \"),getpass(\"Enter password: (+ENTER) \"))\n#ac.whoAmI()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 20,
                "codebleu": {
                    "codebleu": 0.5160742688937765,
                    "ngram_match_score": 0.016891032976324306,
                    "weighted_ngram_match_score": 0.04740604259878138,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.8137884736061096,
                    "recall": 0.8280425071716309,
                    "F1": 0.8208536505699158,
                    "F3": 0.8265947103500366
                },
                "codebertscore_rescaled": {
                    "precision": 0.6275769472122192,
                    "recall": 0.6560850143432617,
                    "F1": 0.6417073011398315,
                    "F3": 0.6531894207000732
                }
            },
            {
                "ind": 14,
                "gen_code": "# Configure plot aesthetics using Matplotlib\nmatplotlib.rc('xtick', labelsize=12) \nmatplotlib.rc('ytick', labelsize=12)\nmatplotlib.rc('axes', labelsize=14, titlesize=16)\nmatplotlib.rc('legend', fontsize=12)\nmatplotlib.rc('font', size=12)\n\n# Define plot colors for different BPT classes if needed\ncolors = {\n    'SF': 'blue',\n    'Seyfert': 'green',\n    'LINER': 'orange',\n    'Composite': 'red'\n}\n\n# Function to create a plot with consistent theme\ndef setup_plot():\n    fig, ax = plt.subplots()\n    ax.grid(True, linestyle='--', alpha=0.7)\n    return fig, ax",
                "true_code": "## Setting up plots\n\n# Font size\nfont = {'size':22}\nmatplotlib.rc('font', **font)\n\n# Axes width\nwidth = {'linewidth':3.0}\nmatplotlib.rc('axes', **width)\n\n# x- and y- ticks\nticks = {'major.size':6.0, 'minor.size':4.0, 'major.width':3.0, 'minor.width':1.5, 'direction':'in',\\\n        'minor.visible':True}\nmatplotlib.rc('xtick', **ticks)\nmatplotlib.rc('ytick', **ticks)\n\n# Include top and right ticks \nplt.rcParams['xtick.top'] = True\nplt.rcParams['ytick.right'] = True",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 3,
                "codebleu": {
                    "codebleu": 0.1699144641302259,
                    "ngram_match_score": 0.005266039344377937,
                    "weighted_ngram_match_score": 0.006043771779299883,
                    "syntax_match_score": 0.36065573770491804,
                    "dataflow_match_score": 0.3076923076923077
                },
                "codebertscore": {
                    "precision": 0.7729184627532959,
                    "recall": 0.7543626427650452,
                    "F1": 0.7635278701782227,
                    "F3": 0.7561780214309692
                },
                "codebertscore_rescaled": {
                    "precision": 0.5458369255065918,
                    "recall": 0.5087252855300903,
                    "F1": 0.5270557403564453,
                    "F3": 0.5123560428619385
                }
            },
            {
                "ind": 16,
                "gen_code": "# Initialize SPARCL client\nsparcl = SparclClient()",
                "true_code": "## SPARCL Client\nclient = SparclClient()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 76,
                "codebleu": {
                    "codebleu": 0.5464347985880404,
                    "ngram_match_score": 0.08307018474412793,
                    "weighted_ngram_match_score": 0.10266900960803409,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8923611044883728,
                    "recall": 0.9454328417778015,
                    "F1": 0.9181306958198547,
                    "F3": 0.9398432970046997
                },
                "codebertscore_rescaled": {
                    "precision": 0.7847222089767456,
                    "recall": 0.890865683555603,
                    "F1": 0.8362613916397095,
                    "F3": 0.8796865940093994
                }
            },
            {
                "ind": 18,
                "gen_code": "# Define emission lines of interest\nemission_lines = [\n    'h_alpha',         # H-alpha\n    'h_beta',          # H-beta\n    'nii_6584',        # [NII] 6584\n    'oiii_5007'        # [OIII] 5007\n]\n\n# Define column names for flux, flux error, and S/N ratio\nflux_cols = [line+'_flux' for line in emission_lines]\nerr_cols = [line+'_flux_err' for line in emission_lines]\nsn_cols = [line+'_sn' for line in emission_lines]\n\nflux_cols, err_cols, sn_cols\n",
                "true_code": "# List of emission lines we are interested in - \nemission_lines = ('Hb_4861', 'OIII_5006', 'Ha_6562', 'NII_6583')\n\n# Creating a list of columns for all the emission lines for Flux, Flux_Err and Aon for each - \nselected_columns_sdss = ', \\n'.join(['E.Flux_{0}, E.Flux_{0}_Err, E.Aon_{0}'.format(e) for e in emission_lines])\n\n# Conditions - \n# Conditions on flux errors (flux errors > 0 and flux errors != Infinity)\nerr_cond_sdss = ' AND \\n'.join(['(E.Flux_{0}_Err > 0) AND (E.Flux_{0}_Err != \\'Infinity\\')'.format(e) for e in emission_lines])\n# Conditions on Signal to Noise ratio of all the emission lines\nsn_cond_sdss = ' AND \\n'.join(['(E.Flux_{0}/E.Flux_{0}_Err > 5)'.format(e) for e in emission_lines])",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 5,
                "codebleu": {
                    "codebleu": 0.14584684086400795,
                    "ngram_match_score": 0.0071499972644728975,
                    "weighted_ngram_match_score": 0.009427021363972762,
                    "syntax_match_score": 0.1875,
                    "dataflow_match_score": 0.3793103448275862
                },
                "codebertscore": {
                    "precision": 0.8062264919281006,
                    "recall": 0.7457021474838257,
                    "F1": 0.7747840881347656,
                    "F3": 0.7513426542282104
                },
                "codebertscore_rescaled": {
                    "precision": 0.6124529838562012,
                    "recall": 0.49140429496765137,
                    "F1": 0.5495681762695312,
                    "F3": 0.5026853084564209
                }
            },
            {
                "ind": 20,
                "gen_code": "# Define the redshift range and additional selection criteria\nz_cond = '(P.redshift >= 0.04) AND (P.redshift <= 0.2)'\n\n# Define query\nquery = f\"\"\"\nSELECT P.specobjid, P.ra, P.dec, P.z as redshift, E.BPTclass, E.type,\n{selected_columns_sdss}\nFROM emissionlinesport_spv AS E\nJOIN specobj AS P\nON E.specobjid = P.specobjid\nWHERE P.class = 'GALAXY' AND P.bestobjid = P.bestobjid \nAND {z_cond} AND {err_cond_sdss} AND {sn_cond_sdss}\n\"\"\"",
                "true_code": "# Write a query for the emission lines from the SDSS DR12 emissionlinesport catalog\n# Applying the S/N cut of >= 5 for all the four emission lines\n# Also applying the conditions that all the flux errors are >0 and != infinity.\n# Applying condition on redshift - only selecting galaxies with 0.02 <= z <= 0.2\n# We add bpt column - which marks the class of the galaxy based on its position on the BPT Diagram\n# We use sdss_joinid to JOIN with SDSS DR16\n# This is to get the SDSS DR16 specobjid of objects - which is used to access the spectra\n\nquery = \"\"\"\nSELECT \nE.ra as ra_sdss, E.dec as dec_sds, E.z, E.bpt,\nE.mjd, E.plate, E.fiberid,\n%s,\nS.specobjid\nFROM sdss_dr12.emissionlinesport as E\nJOIN sdss_dr16.specobj as S\nON (E.sdss_joinid = S.sdss_joinid) AND (E.mjd = S.mjd)\nWHERE (E.z > 0.02) AND (E.z < 0.2) AND\n%s AND\n%s\n\"\"\" %(selected_columns_sdss, err_cond_sdss, sn_cond_sdss)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.1437505299698428,
                    "ngram_match_score": 0.0029478798463693774,
                    "weighted_ngram_match_score": 0.005387573366335133,
                    "syntax_match_score": 0.16666666666666666,
                    "dataflow_match_score": 0.4
                },
                "codebertscore": {
                    "precision": 0.8170475363731384,
                    "recall": 0.7430950403213501,
                    "F1": 0.7783186435699463,
                    "F3": 0.7498822808265686
                },
                "codebertscore_rescaled": {
                    "precision": 0.6340950727462769,
                    "recall": 0.4861900806427002,
                    "F1": 0.5566372871398926,
                    "F3": 0.4997645616531372
                }
            },
            {
                "ind": 22,
                "gen_code": "# Print the query to verify\nprint(query)",
                "true_code": "print(query)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 46,
                "codebleu": {
                    "codebleu": 0.5379880886701025,
                    "ngram_match_score": 0.033031643180138064,
                    "weighted_ngram_match_score": 0.11892071150027214,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.8045588135719299,
                    "recall": 0.9102795720100403,
                    "F1": 0.8541603684425354,
                    "F3": 0.8984734416007996
                },
                "codebertscore_rescaled": {
                    "precision": 0.6091176271438599,
                    "recall": 0.8205591440200806,
                    "F1": 0.7083207368850708,
                    "F3": 0.7969468832015991
                }
            },
            {
                "ind": 24,
                "gen_code": "# Execute the query using queryClient from Data Lab\nfinal_table = qc.query(sql=query, fmt='table')\nfinal_table",
                "true_code": "final_table = qc.query(sql=query, fmt = 'table')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 58,
                "codebleu": {
                    "codebleu": 0.5404083627114851,
                    "ngram_match_score": 0.07069301148938888,
                    "weighted_ngram_match_score": 0.20205155046766235,
                    "syntax_match_score": 0.8888888888888888,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8353837728500366,
                    "recall": 0.9488446116447449,
                    "F1": 0.8885066509246826,
                    "F3": 0.9361302256584167
                },
                "codebertscore_rescaled": {
                    "precision": 0.6707675457000732,
                    "recall": 0.8976892232894897,
                    "F1": 0.7770133018493652,
                    "F3": 0.8722604513168335
                }
            },
            {
                "ind": 27,
                "gen_code": "def get_sdss_spectra(specobjid, rest_frame=True):\n    \"\"\"\n    Retrieve SDSS spectra using the SPARCL client.\n    \n    Parameters:\n    - specobjid: The unique identifier for the SDSS object.\n    - rest_frame: Boolean, if True, returns spectra in the rest-frame.\n    \n    Returns:\n    - wave: Wavelength array\n    - flux: Flux array\n    - model: Model array\n    - ivar: Inverse variance array\n    \"\"\"\n    # Retrieve the spectrum using SPARCL client and the specobjid\n    spectrum = client.get_spectrum(specobjid=specobjid)\n    \n    # Fetch data from the spectrum\n    wave = spectrum['wavelength']\n    flux = spectrum['flux']\n    model = spectrum['model']\n    ivar = spectrum['ivar']\n    \n    if rest_frame:\n        # Adjust wavelength for rest frame by considering the redshift given in spectrum\n        z = spectrum['z']\n        wave = wave / (1 + z)\n    \n    return wave, flux, model, ivar",
                "true_code": "# Function 1 -\n\ndef get_sdss_spectra(specobjid, rest_frame = True):\n    \"\"\"\n    Function to access the SDSS spectra of any object using SPARCL.\n    \n    Returns the arrays of wavelength, flux, model and ivar.\n    Returns the rest-frame arrays if rest_frame = True.\n    If rest_frame = False, returns the observed-frame arrays.\n    \n    Parameters\n    ----------\n    specobjid : int\n        Unique SDSS spectrum id\n        \n    rest_frame : bool\n        Whether or not to return the rest-frame values. Default is True.\n    \n    Returns\n    -------\n    wavelength : array\n        Wavelength array (Rest-frame values if rest_frame = True)\n        \n    flux : array\n        Flux values array (Rest-frame values if rest_frame = True)\n    \n    model : array\n        Model values array (Rest-frame values if rest_frame = True)\n        \n    ivar : array\n        Inverse variance array (Rest-frame values if rest_frame = True)\n\n    \"\"\"\n    \n    ## Retrieve the spectra\n    res = client.retrieve_by_specid(specid_list = [specobjid], \n                                    include = ['sparcl_id', 'specid', 'redshift', 'flux', 'wavelength', 'model', 'ivar'],\n                                    dataset_list = ['SDSS-DR16', 'BOSS-DR16'])\n    ## Record of the spectra\n    res_record = res.records[0]\n    \n    wavelength = res_record.wavelength\n    flux = res_record.flux\n    model = res_record.model\n    ivar = res_record.ivar\n    z = res_record.redshift\n    \n    if (rest_frame == True):\n        # If rest_frame = True, we convert the different arrays into their rest-frame values\n        wavelength = wavelength/(1+z)\n        flux = flux*(1+z)\n        model = model*(1+z)\n        ivar = ivar/((1+z)**2)\n    \n    return (wavelength, flux, model, ivar)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 17,
                "codebleu": {
                    "codebleu": 0.18224042025287268,
                    "ngram_match_score": 0.011617137585445277,
                    "weighted_ngram_match_score": 0.01456676564826768,
                    "syntax_match_score": 0.4861111111111111,
                    "dataflow_match_score": 0.21666666666666667
                },
                "codebertscore": {
                    "precision": 0.8625673055648804,
                    "recall": 0.8220688700675964,
                    "F1": 0.841831386089325,
                    "F3": 0.8259468078613281
                },
                "codebertscore_rescaled": {
                    "precision": 0.7251346111297607,
                    "recall": 0.6441377401351929,
                    "F1": 0.6836627721786499,
                    "F3": 0.6518936157226562
                }
            },
            {
                "ind": 29,
                "gen_code": "# Function 2 -\n\ndef add_lines(redshift, rest_frame=True):\n    \"\"\"\n    Function to add vertical lines to the plots indicating the positions of emission and absorption lines.\n    \n    Takes into account whether the plot is in rest-frame or observed-frame.\n    \n    Parameters\n    ----------\n    redshift : float\n        Redshift of the galaxy/spectrum\n        \n    rest_frame : bool\n        Whether rest-frame lines should be plotted or not. Default is True.\n    \n    \"\"\"\n    \n    # Linestyle for virutal lines\n    linestyle = '--'\n    \n    # Defining emission lines with their wavelengths (given in rest-frame values)\n    em_lines = {\n        'OII_3727': 3727, \n        'OII_3729': 3729, \n        'Hb': 4861,\n        'OIII_4959': 4959,\n        'OIII_5007': 5007,\n        'Ha': 6563,\n        'NII_6584': 6584\n    }\n\n    # Add vertical lines for emission_features\n    for key, wave in em_lines.items():\n        if rest_frame:\n            plt.axvline(wave, ls=linestyle, color='grey')\n            plt.text(wave, plt.ylim()[1]*0.9, key, rotation=90, verticalalignment='bottom')\n        else:\n            wave_obs = wave * (1 + redshift)\n            plt.axvline(wave_obs, ls=linestyle, color='grey')\n            plt.text(wave_obs, plt.ylim()[1]*0.9, key, rotation=90, verticalalignment='bottom')",
                "true_code": "# Function 2 - \n\ndef add_lines(z, ax = None, rest_frame = True, em_label = True, abs_label = True, em_lines = None, abs_lines = None):\n    \"\"\"\n    Function to add emission and/or absorption lines onto a plot. \n    \n    If em_lines or abs_lines is given, plotting only the specified lines.\n    If no lines are given, plotting all the lines that are present in x-range of the plot.\n    \n    Parameters\n    ----------\n    z : float\n        Redshift value of the source\n    \n    ax : AxesSubplot\n        The axis onto which the emission/absoption lines needs to be plotted.\n        If ax = None, then the plotting function uses plt, rather than axis.\n        \n    rest_frame : bool\n        Whether or not the plot is in rest-frame. Default is True.\n    \n    em_label : bool\n        Whether or not to label the emission lines. Default is True.\n        \n    abs_label : bool\n        Whether or not to label the absorption lines. Default is True.\n    \n    em_lines : list\n        List of emission lines to label\n    \n    abs_lines : list\n        List of absorption lines to label\n    \n    Returns\n    -------\n    None\n    \n    \"\"\"\n    \n    # List of lines\n    # This is the set of emission lines from the spZline files. \n    # All the wavelengths are in vaccuum wavelengths.\n\n    # Emission Lines\n    emission_lines = [\n    {\"name\" : \"Ly-alpha\",       \"lambda\" : 1215.67,  \"emission\": True,  \"label\" : \"Ly$\\\\alpha$\"},\n    {\"name\" : \"N V 1240\",       \"lambda\" : 1240.81,  \"emission\": True,  \"label\" : \"N V\"},\n    {\"name\" : \"C IV 1549\",      \"lambda\" : 1549.48,  \"emission\": True,  \"label\" : \"C IV\" },\n    {\"name\" : \"He II 1640\",     \"lambda\" : 1640.42,  \"emission\": True,  \"label\" : \"He II\"},\n    {\"name\" : \"C III] 1908\",    \"lambda\" : 1908.734, \"emission\": True,  \"label\" : \"C III]\"},\n    {\"name\" : \"Mg II 2799\",     \"lambda\" : 2800.315, \"emission\": True,  \"label\" : \"Mg II\" },\n    {\"name\" : \"[O II] 3725\",    \"lambda\" : 3727.092, \"emission\": True,  \"label\" : \" \"},\n    {\"name\" : \"[O II] 3727\",    \"lambda\" : 3729.875, \"emission\": True,  \"label\" : \"[O II]\"}, \n    {\"name\" : \"[Ne III] 3868\",  \"lambda\" : 3869.857, \"emission\": True,  \"label\" : \"[Ne III]\"},\n    {\"name\" : \"H-zeta\",         \"lambda\" : 3890.151, \"emission\": True,  \"label\" : \"H$\\\\zeta$\"},\n    {\"name\" : \"[Ne III] 3970\",  \"lambda\" : 3971.123, \"emission\": True,  \"label\" : \"[Ne III]\"},\n    {\"name\" : \"H-epsilon\",      \"lambda\" : 3971.195, \"emission\": True,  \"label\" : \"H$\\\\epsilon$\"}, \n    {\"name\" : \"H-delta\",        \"lambda\" : 4102.892, \"emission\": True,  \"label\" : \"H$\\\\delta$\"},\n    {\"name\" : \"H-gamma\",        \"lambda\" : 4341.684, \"emission\": True,  \"label\" : \"H$\\\\gamma$\"},\n    {\"name\" : \"[O III] 4363\",   \"lambda\" : 4364.435, \"emission\": True,  \"label\" : \"[O III]\"},\n    {\"name\" : \"He II 4685\",     \"lambda\" : 4686.991, \"emission\": True,  \"label\" : \"He II\"},\n    {\"name\" : \"H-beta\",         \"lambda\" : 4862.683, \"emission\": True,  \"label\" : \"H$\\\\beta$\"},\n    {\"name\" : \"[O III] 4959\",   \"lambda\" : 4960.294, \"emission\": True,  \"label\" : \"[O III]\" },\n    {\"name\" : \"[O III] 5007\",   \"lambda\" : 5008.239, \"emission\": True,  \"label\" : \"[O III]\" },\n    {\"name\" : \"He II 5411\",     \"lambda\" : 5413.025, \"emission\": True,  \"label\" : \"He II\"},\n    {\"name\" : \"[O I] 5577\",     \"lambda\" : 5578.888, \"emission\": True,  \"label\" : \"[O I]\" },\n    {\"name\" : \"[N II] 5755\",    \"lambda\" : 5756.186, \"emission\": True,  \"label\" : \"[Ne II]\" },\n    {\"name\" : \"He I 5876\",      \"lambda\" : 5877.308, \"emission\": True,  \"label\" : \"He I\" },\n    {\"name\" : \"[O I] 6300\",     \"lambda\" : 6302.046, \"emission\": True,  \"label\" : \"[O I]\" },\n    {\"name\" : \"[S III] 6312\",   \"lambda\" : 6313.806, \"emission\": True,  \"label\" : \"[S III]\" },\n    {\"name\" : \"[O I] 6363\",     \"lambda\" : 6365.535, \"emission\": True,  \"label\" : \"[O I]\" },\n    {\"name\" : \"[N II] 6548\",    \"lambda\" : 6549.859, \"emission\": True,  \"label\" : \"[N II]\" },\n    {\"name\" : \"H-alpha\",        \"lambda\" : 6564.614, \"emission\": True,  \"label\" : \"H$\\\\alpha$\" },\n    {\"name\" : \"[N II] 6583\",    \"lambda\" : 6585.268, \"emission\": True,  \"label\" : \"[N II]\" },\n    {\"name\" : \"[S II] 6716\",    \"lambda\" : 6718.294, \"emission\": True,  \"label\" : \"[S II]\" },\n    {\"name\" : \"[S II] 6730\",    \"lambda\" : 6732.678, \"emission\": True,  \"label\" : \"[S II]\" },\n    {\"name\" : \"[Ar III] 7135\",  \"lambda\" : 7137.758, \"emission\": True,  \"label\" : \"[Ar III]\" },]\n\n\n    # Absorption lines\n    absorption_lines = [\n    {\"name\" : \"H12\",            \"lambda\" : 3751.22,  \"emission\": False, \"label\" : \"H12\"},\n    {\"name\" : \"H11\",            \"lambda\" : 3771.70,  \"emission\": False, \"label\" : \"H11\"},\n    {\"name\" : \"H10\",            \"lambda\" : 3798.98,  \"emission\": False, \"label\" : \"H10\"},\n    {\"name\" : \"H9\",             \"lambda\" : 3836.48,  \"emission\": False, \"label\" : \"H9\"},\n    {\"name\" : \"H-zeta\",         \"lambda\" : 3890.151, \"emission\": False, \"label\" : \"H$\\\\zeta$\" },\n    {\"name\" : \"K (Ca II 3933)\", \"lambda\" : 3934.814, \"emission\": False, \"label\" : \"K (Ca II)\"},\n    {\"name\" : \"H (Ca II 3968)\", \"lambda\" : 3969.623, \"emission\": False, \"label\" : \"H (Ca II)\"},\n    {\"name\" : \"H-epsilon\",      \"lambda\" : 3971.195, \"emission\": False, \"label\" : \"H$\\\\epsilon$\"}, \n    {\"name\" : \"H-delta\",        \"lambda\" : 4102.892, \"emission\": False, \"label\" : \"H$\\\\delta$\" },\n    {\"name\" : \"G (Ca I 4307)\",  \"lambda\" : 4308.952, \"emission\": False, \"label\" : \"G (Ca I)\"},\n    {\"name\" : \"H-gamma\",        \"lambda\" : 4341.684, \"emission\": False, \"label\" : \"H$\\\\gamma$\"},\n    {\"name\" : \"H-beta\",         \"lambda\" : 4862.683, \"emission\": False, \"label\" : \"H$\\\\beta$\"},\n#    {\"name\" : \"Mg I 5175\",      \"lambda\" : 5176.441, \"emission\": False, \"label\" : \"Mg I\"},  #Triplet\n    {\"name\" : \"Mg I 5183\",      \"lambda\" : 5185.048, \"emission\": False, \"label\" : \" \"},\n    {\"name\" : \"Mg I 5172\",      \"lambda\" : 5174.125, \"emission\": False, \"label\" : \" \"},\n    {\"name\" : \"Mg I 5167\",      \"lambda\" : 5168.762, \"emission\": False, \"label\" : \"Mg I\"},\n    {\"name\" : \"D2 (Na I 5889)\", \"lambda\" : 5891.582, \"emission\": False, \"label\" : \" \" },\n    {\"name\" : \"D1 (Na I 5895)\", \"lambda\" : 5897.554, \"emission\": False, \"label\" : \"D1,2 (Na I)\" },\n    {\"name\" : \"H-alpha\",        \"lambda\" : 6564.614, \"emission\": False, \"label\" : \"H$\\\\alpha$\"},\n    ]\n    \n    if (ax == None):\n        # If there is no axes given, plotting with the plt function\n        ax = plt.gca()\n    \n    if (em_lines != None):\n        # Choosing the emission lines listed by the user\n        emission_lines = list(filter(lambda x: x['name'] in em_lines, emission_lines))\n    \n    if (abs_lines != None):\n        # Choosing the absorption lines listed by the user\n        absorption_lines = list(filter(lambda x: x['name'] in abs_lines, absorption_lines)) \n    \n    xbounds = ax.get_xbound()   # Getting the x-range of the plot \n    # This is for selecting only those lines that are visible in the x-range of the plot\n    \n    for ii in range(len(emission_lines)):\n        # If rest_frame = False, redshifting the emission lines to the observed frame of the source\n        if (rest_frame == False):\n            lam = emission_lines[ii]['lambda']*(1+z)\n        else:\n            lam = emission_lines[ii]['lambda']\n        # Plotting the emission lines if they are within the x-range of the plot\n        if (emission_lines[ii]['emission']) & (lam > xbounds[0]) & (lam < xbounds[1]):\n            ax.axvline(lam, 0.95, 1.0, color = 'b', lw = 1.0)\n            ax.axvline(lam, color = 'b', lw = 1.0, linestyle = ':')\n            trans = ax.get_xaxis_transform()\n            if (em_label == True):\n                # Labeling the emission lines if em_label = True\n                ax.annotate(emission_lines[ii]['label'], xy = (lam, 1.05), xycoords = trans, \\\n                         fontsize = 12, rotation = 90, color = 'b')\n            \n    for ii in range(len(absorption_lines)):\n        # If rest_frame = False, redshifting the absorption lines to the observed frame of the source\n        if (rest_frame == False):\n            lam = absorption_lines[ii]['lambda']*(1+z)\n        else:\n            lam = absorption_lines[ii]['lambda']\n        # Plotting the absorption lines if they are within the x-range of the plot\n        if (lam > xbounds[0]) & (lam < xbounds[1]):\n            ax.axvline(lam, 0.2, 1.0, color = 'r', lw = 1.0, linestyle = ':')\n            trans = ax.get_xaxis_transform()\n            if (abs_label == True):\n                # Labeling the absorption lines if abs_label = True\n                ax.annotate(absorption_lines[ii]['label'], xy = (lam, 0.05), xycoords = trans, \\\n                         fontsize = 12, rotation = 90, color = 'r')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 5,
                "codebleu": {
                    "codebleu": 0.12404703535703512,
                    "ngram_match_score": 4.7676339801169084e-05,
                    "weighted_ngram_match_score": 0.01680180612725732,
                    "syntax_match_score": 0.44328552803129073,
                    "dataflow_match_score": 0.036053130929791274
                },
                "codebertscore": {
                    "precision": 0.8305585384368896,
                    "recall": 0.7289632558822632,
                    "F1": 0.7764516472816467,
                    "F3": 0.7379904985427856
                },
                "codebertscore_rescaled": {
                    "precision": 0.6611170768737793,
                    "recall": 0.45792651176452637,
                    "F1": 0.5529032945632935,
                    "F3": 0.4759809970855713
                }
            },
            {
                "ind": 31,
                "gen_code": "# Function 3\n\ndef plot_sdss_spectra(specobjid, rest_frame = True, em_label = True, abs_label = True, em_lines = None, abs_lines = None):\n    \"\"\"\n    Function to plot SDSS spectra given its specobjid.\n    Adds emission and absorption lines if specified.\n\n    Parameters\n    ----------\n    specobjid : int\n        Unique SDSS spectrum id\n\n    rest_frame : bool\n        Whether to plot rest-frame values. Default is True.\n\n    em_label : bool\n        Whether to label emission lines. Default is True.\n\n    abs_label : bool\n        Whether to label absorption lines. Default is True.\n    \n    em_lines : list\n        List of emission lines to plot. Default is None.\n    \n    abs_lines : list\n        List of absorption lines to plot. Default is None.\n    \n    Returns\n    -------\n    None\n    \"\"\"\n    \n    # Retrieve spectra\n    wavelength, flux, model, ivar = get_sdss_spectra(specobjid, rest_frame)\n    \n    # Start plotting\n    fig, ax = plt.subplots(figsize=(14, 7))\n    \n    # Plotting the flux\n    ax.plot(wavelength, flux, 'k', lw=0.8, label='Flux')\n    \n    # Plotting the model if available\n    if model is not None:\n        ax.plot(wavelength, model, 'r', lw=0.8, label='Model')\n        \n    ax.set_xlabel(r'Wavelength [$\\mathrm{\\AA}$]')\n    ax.set_ylabel(r'Flux [10$^{-17}$ erg/s/cm$^2$/$\\AA$]')\n    ax.set_title(f'SDSS Spectrum for specobjid = {specobjid}')\n    ax.legend(loc='best', fontsize='x-small')\n    \n    # Adding lines\n    z = 0.0 if rest_frame else get_sdss_spectra(specobjid, rest_frame=False)[0][0] / wavelength[0] - 1\n    add_lines(z, ax, rest_frame, em_label, abs_label, em_lines, abs_lines)\n    \n    plt.show()",
                "true_code": "# Function - 3\n# This function utilises both the above functions\n\ndef plot_sdss_spectra(wavelength, flux, model, ivar, z, rest_frame = True, \\\n                      xlim = None, ylim = None, \\\n                      spectra_kwargs = {'color': 'grey', 'alpha': 0.5}, model_kwargs = {'color': 'k', 'linewidth': 2.0},\\\n                      emission_lines = False, absorption_lines = False, \\\n                      em_lines = None, abs_lines = None):\n    \n    \"\"\"\n    Function to plot the SDSS spectra.\n    \n    Parameters\n    ----------\n    wavelength : array\n        Wavelength array \n        \n    flux : array\n        Flux values array \n    \n    model : array\n        Model values array \n        \n    ivar : array\n        Inverse variance array \n        \n    z : float\n        Redshift of the source\n        \n    rest_frame : bool\n        Whether the input spectra is in rest_frame or not. Default is True.\n    \n    xlim : list or tuple\n        Setting the xrange of the plot\n        \n    ylim : list or tupe\n        Setting the yrange of the plot\n    \n    emission_lines - bool\n        Whether or not to overplot emission lines. Default is False.\n    \n    absorption_lines - bool\n        Whether or not to overplot absorpion lines. Default is False.\n        \n    em_lines - list\n        List of emission lines to plot\n        If not mentioned, all the lines in the default list will be plotted.\n        \n    abs_lines - list\n        List of absorption lines to plot\n        If not mentioned, all the lines in the default list will be plotted.\n    \n    spectra_kwargs - dict\n        Plotting keyword arguments for the spectra\n        \n    model_kwargs - dict\n        Plotting keyword arguments for the model\n        \n    Returns\n    -------\n    None\n    \n    \"\"\"\n    # Setting up the plot\n    plt.figure(figsize = (14,6))\n    plt.plot(wavelength, flux*(ivar > 0), **spectra_kwargs)\n    plt.plot(wavelength, model*(ivar > 0), **model_kwargs)\n    plt.xlim(xlim)\n    plt.ylim(ylim)\n    plt.xlabel('Wavelength ($\\AA$)')\n    plt.ylabel('$F_{\\lambda}$ ($10^{-17}~ergs~s^{-1}~cm^{-2}~\\AA^{-1}$)')\n    \n    # Plotting Absorption/Emission lines - only works if either of the lines is set to True\n    if (emission_lines == True)|(absorption_lines == True):    \n        if (emission_lines == False):\n            # Sending empty array of em_lines if emission_lines = False\n            em_lines = []\n        if (absorption_lines == False):\n            # Sending empty array of abs_lines \n            abs_lines = []\n            \n        # Plotting function to add emission/absorption lines\n        add_lines(ax = None, z = z, rest_frame = rest_frame, \\\n                           em_label = True, abs_label = True, em_lines = em_lines, abs_lines = abs_lines)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 25,
                "codebleu": {
                    "codebleu": 0.22228428499046407,
                    "ngram_match_score": 0.11359007604906259,
                    "weighted_ngram_match_score": 0.14129961493320184,
                    "syntax_match_score": 0.30612244897959184,
                    "dataflow_match_score": 0.328125
                },
                "codebertscore": {
                    "precision": 0.8381113409996033,
                    "recall": 0.8142356872558594,
                    "F1": 0.8260009288787842,
                    "F3": 0.8165618777275085
                },
                "codebertscore_rescaled": {
                    "precision": 0.6762226819992065,
                    "recall": 0.6284713745117188,
                    "F1": 0.6520018577575684,
                    "F3": 0.6331237554550171
                }
            },
            {
                "ind": 33,
                "gen_code": "# Select a galaxy to plot its spectrum\nspecobjid = int(final_table['specobjid'][0])\nz = float(final_table['z'][0])",
                "true_code": "# Assigning variables for the columns required to plot the spectra -\nz = final_table['z'].data\n\n## We need to convert the numpy array of specobjid into a int list to work with SPARCL\nspecobjid = [int(s) for s in final_table['specobjid'].data]",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 40,
                "codebleu": {
                    "codebleu": 0.16395006777538285,
                    "ngram_match_score": 0.008776969428915012,
                    "weighted_ngram_match_score": 0.016720271369586086,
                    "syntax_match_score": 0.26666666666666666,
                    "dataflow_match_score": 0.36363636363636365
                },
                "codebertscore": {
                    "precision": 0.8626091480255127,
                    "recall": 0.773870587348938,
                    "F1": 0.8158339262008667,
                    "F3": 0.7819142937660217
                },
                "codebertscore_rescaled": {
                    "precision": 0.7252182960510254,
                    "recall": 0.547741174697876,
                    "F1": 0.6316678524017334,
                    "F3": 0.5638285875320435
                }
            },
            {
                "ind": 35,
                "gen_code": "# Number of objects in the table\nprint(f\"Number of objects: {len(final_table)}\")",
                "true_code": "# Print number of objects in table\nN_table = len(final_table)\nprint(N_table)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 62,
                "codebleu": {
                    "codebleu": 0.42990626761046896,
                    "ngram_match_score": 0.10600313379512592,
                    "weighted_ngram_match_score": 0.11362193664674995,
                    "syntax_match_score": 0.5,
                    "dataflow_match_score": 0.0
                },
                "codebertscore": {
                    "precision": 0.9058122038841248,
                    "recall": 0.9135591983795166,
                    "F1": 0.9096692204475403,
                    "F3": 0.9127785563468933
                },
                "codebertscore_rescaled": {
                    "precision": 0.8116244077682495,
                    "recall": 0.8271183967590332,
                    "F1": 0.8193384408950806,
                    "F3": 0.8255571126937866
                }
            },
            {
                "ind": 37,
                "gen_code": "# Select the index of the object you want to plot\nindex = 0\n\n# Retrieve spectrum data for the selected object\nwavelength, flux, model, ivar = get_sdss_spectra(specobjid[index])\n\n# Plot the spectrum\nplot_sdss_spectra(wavelength, flux, model, ivar, z[index], xlim=[3800, 9200], ylim=[-1, 15], emission_lines=True, absorption_lines=True)",
                "true_code": "# We will first plot with all the default values - \n# Requires specobjid and z\n\nindex = 10     # Change the value between 0 and N_table-1 to plot different spectra in rest-frame \n\n# Getting the wavelength, flux, model and ivar arrays for the given source\nwavelength, flux, model, ivar = get_sdss_spectra(specobjid[index], rest_frame = True)\nplot_sdss_spectra(wavelength, flux, model, ivar, z[index])",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 4,
                "codebleu": {
                    "codebleu": 0.29395500363400867,
                    "ngram_match_score": 0.12303828473350642,
                    "weighted_ngram_match_score": 0.1242103012310997,
                    "syntax_match_score": 0.42857142857142855,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.848572850227356,
                    "recall": 0.8358659148216248,
                    "F1": 0.8421714901924133,
                    "F3": 0.8371194005012512
                },
                "codebertscore_rescaled": {
                    "precision": 0.6971457004547119,
                    "recall": 0.6717318296432495,
                    "F1": 0.6843429803848267,
                    "F3": 0.6742388010025024
                }
            },
            {
                "ind": 39,
                "gen_code": "# Customizing the plotting parameters - \n# Requires specobjid and z\n\nindex = 10     # Change the value between 0 and N_table-1 to plot different spectra in rest-frame \n\n# Getting the wavelength, flux, model and ivar arrays for the given source\nwavelength, flux, model, ivar = get_sdss_spectra(specobjid[index], rest_frame = True)\n\n# Customizing plot with specific x-axis limits and different colors\nplot_sdss_spectra(wavelength, flux, model, ivar, z[index], \n                  xlim=(3700, 7000), \n                  spectra_kwargs={'color': 'blue', 'alpha': 0.7}, \n                  model_kwargs={'color': 'red', 'linewidth': 2.0})",
                "true_code": "# Changing the default values for the plotting function\n\nindex = 10           # Change the value between 0 and N_table-1 to plot different spectra in rest-frame \n\nplot_sdss_spectra(wavelength, flux, model, ivar, z[index], rest_frame = True, \\\n                      xlim = [4500, 7000], ylim = None, \\\n                      spectra_kwargs = {'color': 'grey', 'alpha': 0.5}, \\\n                      model_kwargs = {'color': 'k', 'linewidth': 2.0},\\\n                      emission_lines = True, absorption_lines = True, \\\n                      em_lines = None,  abs_lines = [])\n\n# The actual spectra from the SDSS is shown in grey and the model is shown in black.\n# You can change it to any color that you want by using the spectra_kwargs and model_kwargs keywords.",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 29,
                "codebleu": {
                    "codebleu": 0.5232195550147485,
                    "ngram_match_score": 0.20430128696742827,
                    "weighted_ngram_match_score": 0.22191026642489906,
                    "syntax_match_score": 0.6666666666666666,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8753827810287476,
                    "recall": 0.836758017539978,
                    "F1": 0.8556347489356995,
                    "F3": 0.8404664397239685
                },
                "codebertscore_rescaled": {
                    "precision": 0.7507655620574951,
                    "recall": 0.673516035079956,
                    "F1": 0.7112694978713989,
                    "F3": 0.680932879447937
                }
            },
            {
                "ind": 41,
                "gen_code": "# Compute Line Ratios\n\nNII_Ha         = np.log10(final_table['E.Flux_NII_6583'] / final_table['E.Flux_Ha_6562'])\nOIII_Hb        = np.log10(final_table['E.Flux_OIII_5006'] / final_table['E.Flux_Hb_4861'])\n\n# Classify Galaxies\n\n# BPT classification\nbpt = final_table['bpt']\nstar_forming = (bpt == 1)\nseyfert = (bpt == 2)\nliner = (bpt == 3)\ncomposite = (bpt == 4)\n\n# Plot BPT diagram\nfig, ax = plt.subplots(figsize=(12, 10))\n\n# 2D histogram for galaxy density\nhist, xedges, yedges = np.histogram2d(NII_Ha, OIII_Hb, bins=100)\nxcenter = (xedges[:-1] + xedges[1:]) / 2\nycenter = (yedges[:-1] + yedges[1:]) / 2\n\n# Contour plot\nax.contourf(xcenter, ycenter, hist.T, levels=10, cmap='Greys', alpha=0.5)\n\n# Scatter plot for galaxy types\nax.scatter(NII_Ha[star_forming], OIII_Hb[star_forming], color='b', label='Star-Forming', s=10)\nax.scatter(NII_Ha[seyfert], OIII_Hb[seyfert], color='r', label='Seyfert', s=10)\nax.scatter(NII_Ha[liner], OIII_Hb[liner], color='g', label='LINER', s=10)\nax.scatter(NII_Ha[composite], OIII_Hb[composite], color='purple', label='Composite', s=10)\n\n# Add labels and legend\nax.set_xlabel(r'$\\log (\\mathrm{[NII] 6583 / H\\alpha})$')\nax.set_ylabel(r'$\\log (\\mathrm{[OIII] 5007 / H\\beta})$')\nax.set_title('BPT Diagram')\nax.legend()\n\nplt.show()",
                "true_code": "# Computing the logarithm of line ratios for the BPT Diagram - \nNii_Ha = np.log10(final_table['flux_nii_6583']/final_table['flux_ha_6562'])\nOiii_Hb = np.log10(final_table['flux_oiii_5006']/final_table['flux_hb_4861'])",
                "error_ind": 41,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.49304946507736774,
                    "ngram_match_score": 0.002022238833799269,
                    "weighted_ngram_match_score": 0.017794669094719398,
                    "syntax_match_score": 0.9523809523809523,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.648456871509552,
                    "recall": 0.8782042860984802,
                    "F1": 0.7460432648658752,
                    "F3": 0.8481542468070984
                },
                "codebertscore_rescaled": {
                    "precision": 0.296913743019104,
                    "recall": 0.7564085721969604,
                    "F1": 0.4920865297317505,
                    "F3": 0.6963084936141968
                }
            },
            {
                "ind": 42,
                "gen_code": "# Assigning variable to the BPT classification column in final_table\nbpt_class = final_table['bpt']\n\n# Boolean conditions for different galaxy types\nsf_galaxies = (bpt_class == 'SF')\nseyfert_galaxies = (bpt_class == 'Seyfert')\ncomposite_galaxies = (bpt_class == 'Composite')\nliner_galaxies = (bpt_class == 'LINER')\n\n# Density histogram for all galaxies\nx_bins = np.linspace(-2.5, 0.5, 50)  # BPT [NII]/Halpha range\ny_bins = np.linspace(-1.2, 1.5, 50)  # BPT [OIII]/Hbeta range\nhist2d, xedges, yedges = np.histogram2d(Nii_Ha, Oiii_Hb, bins=(x_bins, y_bins))\n\n# Plotting the BPT diagram\nplt.figure(figsize=(10, 8))\n\n# Density contours\nplt.contourf(xedges[:-1], yedges[:-1], np.log10(hist2d.T + 1), 50, cmap='Blues', alpha=0.5)\n\n# Scatter plot with galaxy classifications\nplt.scatter(Nii_Ha[sf_galaxies], Oiii_Hb[sf_galaxies], marker='o', color='green', s=10, label='Star Forming')\nplt.scatter(Nii_Ha[seyfert_galaxies], Oiii_Hb[seyfert_galaxies], marker='o', color='red', s=10, label='Seyfert')\nplt.scatter(Nii_Ha[composite_galaxies], Oiii_Hb[composite_galaxies], marker='o', color='yellow', s=10, label='Composite')\nplt.scatter(Nii_Ha[liner_galaxies], Oiii_Hb[liner_galaxies], marker='o', color='purple', s=10, label='LINER')\n\n# Label and axis settings\nplt.xlabel('log([NII] / H\u03b1)', fontsize=14)\nplt.ylabel('log([OIII] / H\u03b2)', fontsize=14)\nplt.title('BPT Diagram', fontsize=16)\nplt.axhline(y=0.0, color='k', linestyle='--', lw=1)\nplt.axvline(x=0.0, color='k', linestyle='--', lw=1)\nplt.xlim(-2.0, 1.0)\nplt.ylim(-1.5, 1.5)\nplt.legend(loc='upper right', fontsize=12)\nplt.grid(True)\nplt.show()",
                "true_code": "# Assigning a variable for the bpt column\nbpt = final_table['bpt']   # BPT Classification\n\n# Creating labels for the different classes based on BPT Column - \nis_sf = (bpt == 'Star Forming')\nis_sy = (bpt == 'Seyfert')\nis_comp = (bpt == 'Composite')\nis_liner = (bpt == 'LINER')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 5,
                "codebleu": {
                    "codebleu": 0.5051748895166716,
                    "ngram_match_score": 0.013672794274920385,
                    "weighted_ngram_match_score": 0.04702676379176597,
                    "syntax_match_score": 0.96,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.6120922565460205,
                    "recall": 0.8583920001983643,
                    "F1": 0.7146151065826416,
                    "F3": 0.8251873254776001
                },
                "codebertscore_rescaled": {
                    "precision": 0.22418451309204102,
                    "recall": 0.7167840003967285,
                    "F1": 0.4292302131652832,
                    "F3": 0.6503746509552002
                }
            },
            {
                "ind": 43,
                "gen_code": "# Creating a 2-d histogram of all the galaxies - \nH, xedges, yedges = np.histogram2d(Nii_Ha, Oiii_Hb, bins = 200)\nH = np.rot90(H)\nH = np.flipud(H)\n# Masking the 0 (i.e. white)\nHmasked = np.ma.masked_where(H == 0, H) \n\nplt.figure(figsize = (14, 10))\n# Plotting the 2d histogram as contour - \nplt.pcolormesh(xedges, yedges, Hmasked, cmap=plt.cm.Greys)\ncbar = plt.colorbar()\ncbar.ax.set_ylabel('Density')\n\n# Plotting Data\nplt.scatter(Nii_Ha[is_sf], Oiii_Hb[is_sf], s = 5, label = 'Star Forming', color = 'blue', alpha = 0.6)\nplt.scatter(Nii_Ha[is_sy], Oiii_Hb[is_sy], s = 5, label = 'Seyfert', color = 'red', alpha = 0.6)\nplt.scatter(Nii_Ha[is_liner], Oiii_Hb[is_liner], s = 5, label = 'LINER', color = 'green', alpha = 0.6)\nplt.scatter(Nii_Ha[is_comp], Oiii_Hb[is_comp], s = 5, label = 'Composite', color = 'orange', alpha = 0.6)\n\nplt.ylabel(r'$\\log \\left( [\\mathbf{OIII}]/ H \\beta \\right)$')\nplt.xlabel(r'$\\log \\left( [\\mathbf{NII}]/ H \\alpha \\right)$')\n\nplt.xlim(-2, 0.8)\nplt.ylim(-1.2, 1.2)\n\nplt.legend()\nplt.grid()\n\nplt.show()",
                "true_code": "# 2-d histogram density of all the galaxies\ndens_all,_,_ = np.histogram2d(Nii_Ha, Oiii_Hb, range=[[-2.0, 0.75],[-1.2, 1.2]], bins=100, density=True)\ndens_all = dens_all.T",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.25951142241597275,
                    "ngram_match_score": 0.027890674581624177,
                    "weighted_ngram_match_score": 0.20313747122261766,
                    "syntax_match_score": 0.3333333333333333,
                    "dataflow_match_score": 0.47368421052631576
                },
                "codebertscore": {
                    "precision": 0.6460375189781189,
                    "recall": 0.8355218172073364,
                    "F1": 0.7286626696586609,
                    "F3": 0.8117141127586365
                },
                "codebertscore_rescaled": {
                    "precision": 0.2920750379562378,
                    "recall": 0.6710436344146729,
                    "F1": 0.4573253393173218,
                    "F3": 0.623428225517273
                }
            },
            {
                "ind": 44,
                "gen_code": "# Plotting the BPT Diagram\nplt.figure(figsize=(10,8))\n\n# Plotting the density in the 2d histogram\nplt.imshow(dens_all, interpolation='nearest', origin='lower', aspect='auto',\n           extent=[-2.0, 0.75, -1.2, 1.2], cmap='Greys')\n\n# Overlaying contour lines\nplt.contour(dens_all, levels=np.logspace(-2.5, 0, 20), extent=[-2.0, 0.75, -1.2, 1.2], linewidths=1, alpha=0.7)\n\n# Scatter plot of the different classes\nplt.scatter(Nii_Ha[is_sf], Oiii_Hb[is_sf], s=10, color='blue', label='Star Forming')\nplt.scatter(Nii_Ha[is_sy], Oiii_Hb[is_sy], s=10, color='red', label='Seyfert')\nplt.scatter(Nii_Ha[is_comp], Oiii_Hb[is_comp], s=10, color='green', label='Composite')\nplt.scatter(Nii_Ha[is_liner], Oiii_Hb[is_liner], s=10, color='purple', label='LINER')\n\nplt.xlim([-2.0, 0.75])\nplt.ylim([-1.2, 1.2])\nplt.xlabel(r'$\\log_{10}([\\mathrm{NII}]/\\mathrm{H}\\alpha)$')\nplt.ylabel(r'$\\log_{10}([\\mathrm{OIII}]/\\mathrm{H}\\beta)$')\nplt.title('BPT Diagram')\nplt.legend(loc='upper left')\nplt.grid(True)\nplt.show()",
                "true_code": "# BPT Diagram color-coded based on the class\nplt.figure(figsize = (8,8))\nplt.scatter(Nii_Ha[is_sy], Oiii_Hb[is_sy], color = 'r', s = 1.0)             # Seyferts in red (r)\nplt.scatter(Nii_Ha[is_sf], Oiii_Hb[is_sf], color = 'b', s = 1.0)             # SF in blue (b)\nplt.scatter(Nii_Ha[is_comp], Oiii_Hb[is_comp], color = 'g', s = 1.0)         # Composites in green (g)\nplt.scatter(Nii_Ha[is_liner], Oiii_Hb[is_liner], color = 'purple', s = 1.0)  # LINERs in purple\nplt.contour(dens_all, colors = 'white', extent = (-2.0, 0.75, -1.2, 1.2), levels = [0.0, 0.1, 0.2, 0.3, 0.5, 1.5, 3.0, 6.0])\nplt.xlim([-2, 0.75])\nplt.ylim([-1.2, 1.2])\nplt.text(-1.0, -0.5, 'SF', color = 'blue', fontsize = 18)\nplt.text(0.0, -1.0, 'Composite', color = 'green', fontsize = 18)\nplt.text(0.5, 0.2, 'LINER', color = 'purple', fontsize = 18, rotation = 90)\nplt.text(-0.9, 1.0, 'Seyfert', color = 'r', fontsize = 18)\nplt.xlabel('log ([NII]/H$\\\\alpha$)')\nplt.ylabel('log ([OIII]/H$\\\\beta$)')\nplt.show()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 18,
                "codebleu": {
                    "codebleu": 0.3459399369918839,
                    "ngram_match_score": 0.013783996765976681,
                    "weighted_ngram_match_score": 0.016187872413680235,
                    "syntax_match_score": 0.6083333333333333,
                    "dataflow_match_score": 0.7454545454545455
                },
                "codebertscore": {
                    "precision": 0.842583954334259,
                    "recall": 0.863213300704956,
                    "F1": 0.852773904800415,
                    "F3": 0.8611049652099609
                },
                "codebertscore_rescaled": {
                    "precision": 0.6851679086685181,
                    "recall": 0.7264266014099121,
                    "F1": 0.7055478096008301,
                    "F3": 0.7222099304199219
                }
            },
            {
                "ind": 48,
                "gen_code": "# Task: Implement the Function to Align and Stack Spectra\n\ndef stack_spectra(tbl, rest_frame=True):\n    \"\"\"\n    Function to stack spectra of SDSS objects.\n    Retrieves individual spectra via SPARCL, aligns them to a reference array,\n    and computes the stacked values via weighted average.\n    \n    Parameters\n    ----------\n    tbl : Table\n        Table of SDSS objects, each associated with `specobjid` and redshift `z`.\n    \n    rest_frame : bool, optional\n        Boolean indicating whether to shift to rest-frame or not. Default is True.\n    \n    Returns\n    -------\n    log_wave_grid : array\n        Reference log wavelength grid.\n    \n    stacked_flux : array\n        Stacked flux values on the reference grid.\n    \n    stacked_model : array\n        Stacked model values on the reference grid.\n    \n    stacked_ivar : array\n        Stacked inverse variance on the reference grid.\n    \"\"\"\n    \n    # Retrieve information\n    specobjid = np.array(tbl['specobjid'], dtype=int)\n    z = tbl['z']\n\n    # Initial retrieval of one spectrum to construct reference wavelength grid\n    loglam0 = np.log10(get_sdss_spectra(specobjid[0], rest_frame=False)[0])\n    step = np.median(np.diff(loglam0))\n    log_wave_grid = np.arange(loglam0[0], loglam0[-1], step)\n    \n    # Arrays for stacking\n    total_flux = np.zeros_like(log_wave_grid)\n    total_model = np.zeros_like(log_wave_grid)\n    total_ivar = np.zeros_like(log_wave_grid)\n    weight = np.zeros_like(log_wave_grid)\n    \n    # Alignment and stacking process\n    for i in range(len(specobjid)):\n        wavelength, flux, model, ivar = get_sdss_spectra(specobjid[i], rest_frame=rest_frame)\n        \n        # Log wavelength grid for the current spectrum\n        loglam = np.log10(wavelength)\n        \n        # Alignment by interpolation\n        interp_flux = np.interp(log_wave_grid, loglam, flux, left=0, right=0)\n        interp_model = np.interp(log_wave_grid, loglam, model, left=0, right=0)\n        interp_ivar = np.interp(log_wave_grid, loglam, ivar, left=0, right=0)\n        \n        # Calculating the weight ensuring correct flux stacking\n        total_flux += interp_flux * interp_ivar\n        total_model += interp_model * interp_ivar\n        weight += interp_ivar\n        \n        # Inverse variance stacking\n        total_ivar += interp_ivar\n    \n    # Final stacked arrays\n    stacked_flux = total_flux / weight\n    stacked_model = total_model / weight\n    stacked_ivar = total_ivar\n    \n    return log_wave_grid, stacked_flux, stacked_model, stacked_ivar",
                "true_code": "## Function 4 -\n\ndef stack_spectra(table):\n    \"\"\"\n    Function to Stack the spectra of all the sources in the given table.\n    Uses SPARCL to retrieve spectra\n    \n    Returns an inverse variance weighted mean of the input spectra.\n    \n    Parameters\n    ----------\n    table : table\n        Table of sources whose spectra need to be stacked\n    \n    Returns\n    -------\n    wavelength_stack : array\n        Wavelength array of the stacked spectra\n        \n    flux_stack : array\n        Flux array of the stacked spectra\n    \n    model_stack : array\n        Model array of the stacked spectra\n    \n    \"\"\"\n    \n    # Create an array with the targeted loglam values - reference array\n    loglam_ref = np.arange(3.5000, 3.9000, 0.0001).astype('float32')\n    \n    # Create empty lists for flux, ivar and model - \n    flux_array = []\n    model_array = []\n    ivar_array = []\n    \n    # Extract the necessary columns from the table\n    # redshift = table['z']\n    specobjid = [int(s) for s in table['specobjid'].data]\n    \n    # Number of spectra - \n    n = len(table)\n    \n    ## Retrieve the spectra\n    res = client.retrieve_by_specid(specid_list = specobjid, \n                                    include = ['sparcl_id', 'specid', 'redshift', 'flux', 'wavelength', 'model', 'ivar'],\n                                    dataset_list = ['SDSS-DR16', 'BOSS-DR16'])\n    \n    ## All the spectra have the same spacing in log wavelength.\n    ## We shift the spectra in the observed wavelength range to fill the same log wavelength range\n    ## Join the different arrays of the individual spectra into a single array\n    \n    ## Compared the number of retrieved spectra to the number of requested spectra\n    ## NOTE: some datasets have missing spectra with inconsistent data models, which will be added at the \n    ##       next re-ingestion. Stats available here: https://astrosparcl.datalab.noirlab.edu/sparc/datasetnotes/\n    n_res = res.count\n    n_use = np.min([n_res, n])\n    if n_res!=n:\n        print(f\"WARNING: {n_res} spectra were retrieved from the requested {n}! Will proceed with {n_use} spectra.\")\n        \n    for ii in range(n_use):   \n                \n        ## Get rest-frame spectra of each object\n        res_rec = res.records[ii]\n        z = res_rec.redshift\n        lam = res_rec.wavelength/(1+z)\n        flux = res_rec.flux*(1+z)\n        model = res_rec.model*(1+z)\n        ivar = res_rec.ivar/((1+z)**2)\n        \n        loglam = np.around(np.log10(lam), 4).astype('float32')\n        # The log of reference wavelength and log of wavelength range of each spectra are converted to 'float32'\n        # This helps in avoiding the rounding errors\n        \n        # Creating empty arrays for flux, inverse variance and model \n        # with the same length as the reference loglam array\n        fl = np.zeros(len(loglam_ref))\n        iv = np.zeros(len(loglam_ref))\n        ml = np.zeros(len(loglam_ref))\n        \n        # Truth_array - A boolen array which will define what pixels the spectra have been shifted to\n        truth_array = np.zeros(len(loglam_ref), dtype = bool)\n        \n        # Find common elements between the reference and spectra wavelengths - \n        ll_common = np.intersect1d(loglam_ref, loglam)\n        \n        # Finding the indices of the first pixel in the common array in both reference and spectrum arrays\n        ref_start = np.where(loglam_ref == ll_common[0])[0][0]\n        spec_start = np.where(loglam == ll_common[0])[0][0]\n        \n        m = min(len(loglam_ref[ref_start:]), len(loglam[spec_start:]))\n        \n        # Match the first pixel of the common loglam values with the reference array \n        # Mark the number of pixels with the spectra starting from the first pixel to be True\n        truth_array[ref_start:ref_start+m] = True\n\n        # Fill the flux, inverse variance and model arrays\n        fl[truth_array] = flux[spec_start:spec_start+m]\n        iv[truth_array] = ivar[spec_start:spec_start+m]\n        ml[truth_array] = model[spec_start:spec_start+m]\n        \n        # Where the reference array is empty, fill the flux and model with nan values\n        # Set inverse variance to zero for these pixels\n        fl[~truth_array] = np.nan\n        iv[~truth_array] = 0.0\n        ml[~truth_array] = np.nan\n        \n        # Create a masked array with 'nan' values marked\n        # This avoids the pixels filled with 'nan' when stacking\n        fl = np.ma.masked_array(fl, np.isnan(fl))\n        iv = np.ma.masked_array(iv, np.isnan(iv))\n        ml = np.ma.masked_array(ml, np.isnan(ml))\n        \n        flux_array.append(fl)\n        model_array.append(ml)\n        ivar_array.append(iv)\n        \n    # Stack the spectra by weighted average \n    wavelength_stack = 10**(loglam_ref)\n    flux_stack = np.ma.average(flux_array, axis = 0, weights = ivar_array)\n    model_stack = np.ma.average(model_array, axis = 0, weights = ivar_array)\n    \n    flux_stack = flux_stack.filled(np.nan)\n    model_stack = model_stack.filled(np.nan)\n    \n    return (wavelength_stack, flux_stack, model_stack)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 11,
                "codebleu": {
                    "codebleu": 0.1154318645176172,
                    "ngram_match_score": 0.004549276622536622,
                    "weighted_ngram_match_score": 0.0070655688353195275,
                    "syntax_match_score": 0.32094594594594594,
                    "dataflow_match_score": 0.12916666666666668
                },
                "codebertscore": {
                    "precision": 0.825709342956543,
                    "recall": 0.7759289145469666,
                    "F1": 0.8000454902648926,
                    "F3": 0.7806352376937866
                },
                "codebertscore_rescaled": {
                    "precision": 0.6514186859130859,
                    "recall": 0.5518578290939331,
                    "F1": 0.6000909805297852,
                    "F3": 0.5612704753875732
                }
            },
            {
                "ind": 50,
                "gen_code": "# Define the square boundaries \n# Lower left corners of each square\n\nSF_square = [-0.8, -0.2]\ncomp_square = [-0.2, -0.1]\nLINER_square = [0.1, 0.05]\nsy_square = [-0.4, 0.7]\n\n# The width and height of each box\nwidth, height = 0.2, 0.2",
                "true_code": "## Defining vertices the lower-left corners of the four squares\nsy_x, sy_y = -0.15, 0.55\nsf_x, sf_y = -0.65, -0.05\nliner_x, liner_y = 0.0, 0.05\ncomp_x, comp_y = -0.25, 0.0\n\n# Defining the width and height size\nwidth = 0.1\nheight = 0.1",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 6,
                "codebleu": {
                    "codebleu": 0.15362353224304412,
                    "ngram_match_score": 0.03642442681430881,
                    "weighted_ngram_match_score": 0.038069702157867695,
                    "syntax_match_score": 0.44,
                    "dataflow_match_score": 0.1
                },
                "codebertscore": {
                    "precision": 0.8607274293899536,
                    "recall": 0.837080717086792,
                    "F1": 0.8487393856048584,
                    "F3": 0.8393867611885071
                },
                "codebertscore_rescaled": {
                    "precision": 0.7214548587799072,
                    "recall": 0.674161434173584,
                    "F1": 0.6974787712097168,
                    "F3": 0.6787735223770142
                }
            },
            {
                "ind": 52,
                "gen_code": "# Plotting BPT Diagram regions using rectangles to indicate where we will select galaxies\nplt.figure(figsize = (8,8))\nplt.scatter(Nii_Ha[is_sy], Oiii_Hb[is_sy], color = 'r', s = 1.0)             # Seyferts in red (r)\nplt.scatter(Nii_Ha[is_sf], Oiii_Hb[is_sf], color = 'b', s = 1.0)             # SF in blue (b)\nplt.scatter(Nii_Ha[is_comp], Oiii_Hb[is_comp], color = 'g', s = 1.0)         # Composites in green (g)\nplt.scatter(Nii_Ha[is_liner], Oiii_Hb[is_liner], color = 'purple', s = 1.0)  # LINERs in purple\nplt.contour(dens_all, colors = 'white', extent = (-2.0, 0.75, -1.2, 1.2), levels = [0.0, 0.1, 0.2, 0.3, 0.5, 1.5, 3.0, 6.0])\n\n# Adding rectangle representations for selection regions\nrect_sy = Rectangle((sy_x, sy_y), width, height, fill=False, edgecolor='white', linewidth=2)\nrect_sf = Rectangle((sf_x, sf_y), width, height, fill=False, edgecolor='white', linewidth=2)\nrect_liner = Rectangle((liner_x, liner_y), width, height, fill=False, edgecolor='white', linewidth=2)\nrect_comp = Rectangle((comp_x, comp_y), width, height, fill=False, edgecolor='white', linewidth=2)\n\n# Adding rectangles to plot\nplt.gca().add_patch(rect_sy)\nplt.gca().add_patch(rect_sf)\nplt.gca().add_patch(rect_liner)\nplt.gca().add_patch(rect_comp)\n\nplt.xlim([-2, 0.75])\nplt.ylim([-1.2, 1.2])\nplt.xlabel('log ([NII]/H$\\\\alpha$)')\nplt.ylabel('log ([OIII]/H$\\\\beta$)')\nplt.title('BPT Diagram with Selection Regions')\nplt.show()",
                "true_code": "s1= Rectangle(xy = (sy_x, sy_y), width = width, height = height, color = 'white', lw = 3.0, fill = False)\ns2 = Rectangle(xy = (sf_x, sf_y), width = width, height = height, color = 'white', lw = 3.0, fill = False)\ns3 = Rectangle(xy = (liner_x, liner_y), width = width, height = height, color = 'white', lw = 3.0, fill = False)\ns4 = Rectangle(xy = (comp_x, comp_y), width = width, height = height, color = 'white', lw = 3.0, fill = False)\n\nplt.figure(figsize = (8,8))\n\nplt.scatter(Nii_Ha[is_sy], Oiii_Hb[is_sy], color = 'r', s = 1.0)\nplt.scatter(Nii_Ha[is_sf], Oiii_Hb[is_sf], color = 'b', s = 1.0)\nplt.scatter(Nii_Ha[is_comp], Oiii_Hb[is_comp], color = 'g', s = 1.0)\nplt.scatter(Nii_Ha[is_liner], Oiii_Hb[is_liner], color = 'purple', s = 1.0)\nplt.gca().add_patch(s1)\nplt.gca().add_patch(s2)\nplt.gca().add_patch(s3)\nplt.gca().add_patch(s4)\nplt.text(-1.0, -0.5, 'SF', color = 'blue', fontsize = 18)\nplt.text(0.0, -1.0, 'Composite', color = 'green', fontsize = 18)\nplt.text(0.5, 0.2, 'LINER', color = 'purple', fontsize = 18, rotation = 90)\nplt.text(-0.9, 1.0, 'Seyfert', color = 'r', fontsize = 18)\nplt.xlim([-2, 0.75])\nplt.ylim([-1.2, 1.2])\nplt.xlabel('log ([NII]/H$\\\\alpha$)')\nplt.ylabel('log ([OIII]/H$\\\\beta$)')\n\nplt.show()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 33,
                "codebleu": {
                    "codebleu": 0.4182794472677894,
                    "ngram_match_score": 0.23210818315196952,
                    "weighted_ngram_match_score": 0.23306646210647902,
                    "syntax_match_score": 0.7771739130434783,
                    "dataflow_match_score": 0.4307692307692308
                },
                "codebertscore": {
                    "precision": 0.8567435145378113,
                    "recall": 0.8860375881195068,
                    "F1": 0.8711442947387695,
                    "F3": 0.8830183744430542
                },
                "codebertscore_rescaled": {
                    "precision": 0.7134870290756226,
                    "recall": 0.7720751762390137,
                    "F1": 0.7422885894775391,
                    "F3": 0.7660367488861084
                }
            },
            {
                "ind": 54,
                "gen_code": "# Finding indices of sources within the defined regions\n\nsf_indices = np.where((Nii_Ha > sf_x) & (Nii_Ha < sf_x + width) & (Oiii_Hb > sf_y) & (Oiii_Hb < sf_y + height))[0]\nsy_indices = np.where((Nii_Ha > sy_x) & (Nii_Ha < sy_x + width) & (Oiii_Hb > sy_y) & (Oiii_Hb < sy_y + height))[0]\ncomp_indices = np.where((Nii_Ha > comp_x) & (Nii_Ha < comp_x + width) & (Oiii_Hb > comp_y) & (Oiii_Hb < comp_y + height))[0]\nliner_indices = np.where((Nii_Ha > liner_x) & (Nii_Ha < liner_x + width) & (Oiii_Hb > liner_y) & (Oiii_Hb < liner_y + height))[0]",
                "true_code": "# Regions of the white boxes - \n# Getting the indices of the sources within the four boxes\nsy_box = np.where((Nii_Ha >= sy_x) & (Nii_Ha <= sy_x+width) & (Oiii_Hb >= sy_y) & (Oiii_Hb <= sy_y+height))[0]\nsf_box = np.where((Nii_Ha >= sf_x) & (Nii_Ha <= sf_x+width) & (Oiii_Hb >= sf_y) & (Oiii_Hb <= sf_y+height))[0]\nliner_box = np.where((Nii_Ha >= liner_x) & (Nii_Ha <= liner_x+width) & (Oiii_Hb >= liner_y) & (Oiii_Hb <= liner_y+height))[0]\ncomp_box = np.where((Nii_Ha >= comp_x) & (Nii_Ha <= comp_x+width) & (Oiii_Hb >= comp_y) & (Oiii_Hb <= comp_y+height))[0]",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 31,
                "codebleu": {
                    "codebleu": 0.5329079806636847,
                    "ngram_match_score": 0.06319785773174377,
                    "weighted_ngram_match_score": 0.06843406492299485,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9456777572631836,
                    "recall": 0.943474531173706,
                    "F1": 0.9445748329162598,
                    "F3": 0.9436943531036377
                },
                "codebertscore_rescaled": {
                    "precision": 0.8913555145263672,
                    "recall": 0.8869490623474121,
                    "F1": 0.8891496658325195,
                    "F3": 0.8873887062072754
                }
            },
            {
                "ind": 56,
                "gen_code": "# Randomly selecting 100 spectra from each box for stacking\n\nn_stack = 100 # define how many samples for stacking\n\nsy_rand = random.sample(list(sy_box), n_stack)\nsf_rand = random.sample(list(sf_box), n_stack)\nliner_rand = random.sample(list(liner_box), n_stack)\ncomp_rand = random.sample(list(comp_box), n_stack)",
                "true_code": "# Selecting 100 sources from each box and joining their rows into a table\nn = 100\n\n# Indices of 100 objects within each box\nsy_sel = np.sort(random.sample(list(sy_box), n))\nsf_sel = np.sort(random.sample(list(sf_box), n))\nliner_sel = np.sort(random.sample(list(liner_box), n))\ncomp_sel = np.sort(random.sample(list(comp_box), n))\n\n# Tables of the selections\ntab_sy = final_table[sy_sel]\ntab_sf = final_table[sf_sel]\ntab_liner = final_table[liner_sel]\ntab_comp = final_table[comp_sel]",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 26,
                "codebleu": {
                    "codebleu": 0.2527784966083577,
                    "ngram_match_score": 0.027706060253598834,
                    "weighted_ngram_match_score": 0.032419783887342075,
                    "syntax_match_score": 0.4727272727272727,
                    "dataflow_match_score": 0.4782608695652174
                },
                "codebertscore": {
                    "precision": 0.8692771196365356,
                    "recall": 0.8191711902618408,
                    "F1": 0.8434807062149048,
                    "F3": 0.8239203691482544
                },
                "codebertscore_rescaled": {
                    "precision": 0.7385542392730713,
                    "recall": 0.6383423805236816,
                    "F1": 0.6869614124298096,
                    "F3": 0.6478407382965088
                }
            },
            {
                "ind": 58,
                "gen_code": "wavelength_sy, flux_sy, model_sy = stack_spectra(tab_sy)\nwavelength_sf, flux_sf, model_sf = stack_spectra(tab_sf)\nwavelength_liner, flux_liner, model_liner = stack_spectra(tab_liner)\nwavelength_comp, flux_comp, model_comp = stack_spectra(tab_comp)",
                "true_code": "# Stacked spectra for the 100 sources within each white box\nlam_sy, flux_sy, model_sy = stack_spectra(tab_sy)\nlam_sf, flux_sf, model_sf = stack_spectra(tab_sf)\nlam_liner, flux_liner, model_liner = stack_spectra(tab_liner)\nlam_comp, flux_comp, model_comp = stack_spectra(tab_comp)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 2,
                "codebleu": {
                    "codebleu": 0.6419929874219238,
                    "ngram_match_score": 0.27661427010404904,
                    "weighted_ngram_match_score": 0.29135767958364606,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9380274415016174,
                    "recall": 0.9035847187042236,
                    "F1": 0.9204840660095215,
                    "F3": 0.9069147706031799
                },
                "codebertscore_rescaled": {
                    "precision": 0.8760548830032349,
                    "recall": 0.8071694374084473,
                    "F1": 0.840968132019043,
                    "F3": 0.8138295412063599
                }
            },
            {
                "ind": 60,
                "gen_code": "# Plotting Stacked Spectra\n\nplt.figure(figsize = (14,10))\n\n# Seyferts\nplt.subplot(2, 2, 1)\nplt.plot(lam_sy, flux_sy, color='r', label='Seyfert')\nplt.xlabel('$\\lambda [\\AA]$')\nplt.ylabel('$F_{\\lambda}$')\nplt.xlim([3500, 7000])\nplt.legend()\n\n# Star-Forming galaxies\nplt.subplot(2, 2, 2)\nplt.plot(lam_sf, flux_sf, color='b', label='Star-Forming')\nplt.xlabel('$\\lambda [\\AA]$')\nplt.ylabel('$F_{\\lambda}$')\nplt.xlim([3500, 7000])\nplt.legend()\n\n# LINERs\nplt.subplot(2, 2, 3)\nplt.plot(lam_liner, flux_liner, color='purple', label='LINER')\nplt.xlabel('$\\lambda [\\AA]$')\nplt.ylabel('$F_{\\lambda}$')\nplt.xlim([3500, 7000])\nplt.legend()\n\n# Composite\nplt.subplot(2, 2, 4)\nplt.plot(lam_comp, flux_comp, color='g', label='Composite')\nplt.xlabel('$\\lambda [\\AA]$')\nplt.ylabel('$F_{\\lambda}$')\nplt.xlim([3500, 7000])\nplt.legend()\n\nplt.tight_layout()\nplt.show()",
                "true_code": "fig, axs = plt.subplots(4,1, figsize = (12, 12), sharex = True, sharey = True)\nplt.subplots_adjust(wspace = 0., hspace = 0.)\n\naxs[0].plot(lam_sy, flux_sy, color = 'r', label = 'Seyferts')\naxs[0].legend(fontsize = 14, loc = 'upper left')\naxs[0].set_ylabel('$F_{\\lambda}$')\n\naxs[1].plot(lam_sf, flux_sf, color = 'b', label = 'Star-Forming')\naxs[1].legend(fontsize = 14, loc = 'upper left')\naxs[1].set_ylabel('$F_{\\lambda}$')\n\naxs[2].plot(lam_liner, flux_liner, color = 'purple', label = 'LINERs')\naxs[2].legend(fontsize = 14, loc = 'upper left')\naxs[2].set_ylabel('$F_{\\lambda}$')\n\naxs[3].plot(lam_comp, flux_comp, color = 'g', label = 'Composite')\naxs[3].legend(fontsize = 14, loc = 'upper left')\naxs[3].set_xlim([3510, 7010])\naxs[3].set_xlabel('$\\lambda$')\naxs[3].set_ylabel('$F_{\\lambda}$');",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 14,
                "codebleu": {
                    "codebleu": 0.1389397281361174,
                    "ngram_match_score": 0.003045357429442951,
                    "weighted_ngram_match_score": 0.0031103805118520757,
                    "syntax_match_score": 0.3888888888888889,
                    "dataflow_match_score": 0.16071428571428573
                },
                "codebertscore": {
                    "precision": 0.8526511192321777,
                    "recall": 0.8234649896621704,
                    "F1": 0.8378039598464966,
                    "F3": 0.826293408870697
                },
                "codebertscore_rescaled": {
                    "precision": 0.7053022384643555,
                    "recall": 0.6469299793243408,
                    "F1": 0.6756079196929932,
                    "F3": 0.652586817741394
                }
            },
            {
                "ind": 62,
                "gen_code": "fig, axs = plt.subplots(4, 2, figsize=(15, 18), sharey='row')\nplt.subplots_adjust(wspace = 0.2, hspace = 0.3)\n\n# Plotting parameters\nxlim_OIII = [4810, 5090]\nxlim_Ha = [6250, 6900]\nspectra_kwargs = {'color': None, 'alpha': 0.8}\nlinewidth = 2.0\n\n# Seyfert\naxs[0, 0].plot(lam_sy, flux_sy, color='r', linewidth=linewidth)\nadd_lines(z=0, ax=axs[0, 0], rest_frame=True, emission_lines=True)\naxs[0, 0].set_xlim(xlim_OIII)\naxs[0, 0].set_title('Seyferts - [OIII] region')\n\naxs[0, 1].plot(lam_sy, flux_sy, color='r', linewidth=linewidth)\nadd_lines(z=0, ax=axs[0, 1], rest_frame=True, emission_lines=True)\naxs[0, 1].set_xlim(xlim_Ha)\naxs[0, 1].set_title('H\u03b1 region')\n\n# Star-Forming\naxs[1, 0].plot(lam_sf, flux_sf, color='b', linewidth=linewidth)\nadd_lines(z=0, ax=axs[1, 0], rest_frame=True, emission_lines=True)\naxs[1, 0].set_xlim(xlim_OIII)\naxs[1, 0].set_title('Star-Forming - [OIII] region')\n\naxs[1, 1].plot(lam_sf, flux_sf, color='b', linewidth=linewidth)\nadd_lines(z=0, ax=axs[1, 1], rest_frame=True, emission_lines=True)\naxs[1, 1].set_xlim(xlim_Ha)\naxs[1, 1].set_title('H\u03b1 region')\n\n# LINERs\naxs[2, 0].plot(lam_liner, flux_liner, color='purple', linewidth=linewidth)\nadd_lines(z=0, ax=axs[2, 0], rest_frame=True, emission_lines=True)\naxs[2, 0].set_xlim(xlim_OIII)\naxs[2, 0].set_title('LINERs - [OIII] region')\n\naxs[2, 1].plot(lam_liner, flux_liner, color='purple', linewidth=linewidth)\nadd_lines(z=0, ax=axs[2, 1], rest_frame=True, emission_lines=True)\naxs[2, 1].set_xlim(xlim_Ha)\naxs[2, 1].set_title('H\u03b1 region')\n\n# Composite\naxs[3, 0].plot(lam_comp, flux_comp, color='g', linewidth=linewidth)\nadd_lines(z=0, ax=axs[3, 0], rest_frame=True, emission_lines=True)\naxs[3, 0].set_xlim(xlim_OIII)\naxs[3, 0].set_title('Composite - [OIII] region')\naxs[3, 0].set_xlabel('Wavelength ($\\AA$)')\naxs[3, 0].set_ylabel('$F_{\\lambda}$ (Composite)')\n\naxs[3, 1].plot(lam_comp, flux_comp, color='g', linewidth=linewidth)\nadd_lines(z=0, ax=axs[3, 1], rest_frame=True, emission_lines=True)\naxs[3, 1].set_xlim(xlim_Ha)\naxs[3, 1].set_title('H\u03b1 region')\naxs[3, 1].set_xlabel('Wavelength ($\\AA$)')\n\nplt.show()",
                "true_code": "fig, axs = plt.subplots(4,2, figsize = (16,12), sharey = True, sharex = 'col')\nplt.subplots_adjust(wspace = 0.05, hspace = 0.0)\n\naxs[0][0].plot(lam_sy, flux_sy, color = 'r', label = 'Seyferts')\naxs[0][0].legend(fontsize = 14, loc = 'upper left')\naxs[0][0].set_ylabel('$F_{\\lambda}$')\naxs[0][0].set_xlim([4810, 5090])\nadd_lines(ax = axs[0][0], z=0, abs_lines = [])\n\naxs[1][0].plot(lam_sf, flux_sf, color = 'b', label = 'Star-Forming')\naxs[1][0].legend(fontsize = 14, loc = 'upper left')\naxs[1][0].set_ylabel('$F_{\\lambda}$')\nadd_lines(ax = axs[1][0], z=0, rest_frame = True, abs_lines = [], em_label = False)\n\naxs[2][0].plot(lam_liner, flux_liner, color = 'purple', label = 'LINERs')\naxs[2][0].legend(fontsize = 14, loc = 'upper left')\naxs[2][0].set_ylabel('$F_{\\lambda}$')\naxs[2][0].set_xlabel('$\\lambda$')\nadd_lines(ax = axs[2][0], z=0, rest_frame = True, abs_lines = [], em_label = False)\n                \naxs[3][0].plot(lam_comp, flux_comp, color = 'g', label = 'Composite')\naxs[3][0].legend(fontsize = 14, loc = 'upper left')\naxs[3][0].set_ylabel('$F_{\\lambda}$')\naxs[3][0].set_xlabel('$\\lambda$')\nadd_lines(ax = axs[3][0], z=0, rest_frame = True, abs_lines = [], em_label = False)\n\naxs[0][1].plot(lam_sy, flux_sy, color = 'r', label = 'Seyferts')\naxs[0][1].set_xlim([6250, 6900])\nadd_lines(ax = axs[0][1], z=0, rest_frame = True, abs_lines = [])\n\naxs[1][1].plot(lam_sf, flux_sf, color = 'b', label = 'Star-Forming')\nadd_lines(ax = axs[1][1], z=0, rest_frame = True, abs_lines = [], em_label = False)\n\naxs[2][1].plot(lam_liner, flux_liner, color = 'purple', label = 'LINERs')\nadd_lines(ax = axs[2][1], z=0, rest_frame = True, abs_lines = [], em_label = False)\n\naxs[3][1].plot(lam_comp, flux_comp, color = 'g', label = 'Composite')\naxs[3][1].set_xlabel('$\\lambda$')\nadd_lines(ax = axs[3][1], z=0, rest_frame = True, abs_lines = [], em_label = False)",
                "error_ind": 62,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.2101606059218245,
                    "ngram_match_score": 0.007573594581226624,
                    "weighted_ngram_match_score": 0.007704810620666969,
                    "syntax_match_score": 0.328719723183391,
                    "dataflow_match_score": 0.4966442953020134
                },
                "codebertscore": {
                    "precision": 0.8618329763412476,
                    "recall": 0.8936847448348999,
                    "F1": 0.8774698972702026,
                    "F3": 0.8903940320014954
                },
                "codebertscore_rescaled": {
                    "precision": 0.7236659526824951,
                    "recall": 0.7873694896697998,
                    "F1": 0.7549397945404053,
                    "F3": 0.7807880640029907
                }
            }
        ],
        "result_summary": {
            "direct_match": 0.0,
            "fuzzy_match": 21.925925925925927,
            "codebleu": 0.3328987277902248,
            "syntax_match_score": 0.5960430487276902,
            "codebertscore": 0.8291052204591257,
            "codebertscore_rescaled": 0.6582104409182513,
            "code_success": 0.9259259259259259,
            "total_code_cell_count": 27
        }
    },
    {
        "notebook": {
            "assignment": "02_DESI_EDR_SDSS_Comparison_assignment.ipynb",
            "reference": "/Users/saj2765/Desktop/astro/rare-packages-code-gen/notebook_analysis/notebooks-latest/03_ScienceExamples/DESI/02_DESI_EDR_SDSS_Comparison.ipynb",
            "prefix": "desi_1"
        },
        "model": {
            "model": "gpt-4o",
            "library": "OA"
        },
        "result": [
            {
                "ind": 1,
                "gen_code": "__nbid__ = \"0006\"\n__author__ = \"Ragadeepika Pucha <ragadeepika@example.com>, Stephanie Juneau <sjuneau@example.com>\"\n__version__ = \"20231005\"\n__datasets__ = [\"SDSS Data Release 16\", \"DESI Early Data Release\"]\n__keywords__ = [\"SPARCL\", \"spectra\", \"database queries\"]",
                "true_code": "__nbid__ = '0006'\n__author__ = 'Ragadeepika Pucha <rpucha@arizona.edu>, Stephanie Juneau <stephanie.juneau@noirlab.edu>' \n__version__ = '20240603' # yyyymmdd\n__datasets__ = ['sdss_dr16', 'desi_edr']  \n__keywords__ = ['sparcl', 'spectra', 'database'] ",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 46,
                "codebleu": {
                    "codebleu": 0.5182589325642506,
                    "ngram_match_score": 0.0329999581142483,
                    "weighted_ngram_match_score": 0.040035772142754174,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8665428161621094,
                    "recall": 0.8378811478614807,
                    "F1": 0.8519710302352905,
                    "F3": 0.8406617045402527
                },
                "codebertscore_rescaled": {
                    "precision": 0.7330856323242188,
                    "recall": 0.6757622957229614,
                    "F1": 0.703942060470581,
                    "F3": 0.6813234090805054
                }
            },
            {
                "ind": 9,
                "gen_code": "plt.rcParams.update({\n    'font.size': 14,\n    'axes.linewidth': 1.5,\n    'xtick.major.size': 8,\n    'ytick.major.size': 8,\n    'xtick.minor.size': 4,\n    'ytick.minor.size': 4,\n    'xtick.major.width': 1.2,\n    'ytick.major.width': 1.2,\n    'xtick.minor.width': 1.0,\n    'ytick.minor.width': 1.0,\n    'figure.figsize': (10, 6),\n    'figure.dpi': 100,\n    'legend.fontsize': 12\n})",
                "true_code": "## Making the matplotlib plots look nicer\nsettings = {\n    'font.size':20,\n    'axes.linewidth':2.0,\n    'xtick.major.size':6.0,\n    'xtick.minor.size':4.0,\n    'xtick.major.width':2.0,\n    'xtick.minor.width':1.5,\n    'xtick.direction':'in', \n    'xtick.minor.visible':True,\n    'xtick.top':True,\n    'ytick.major.size':6.0,\n    'ytick.minor.size':4.0,\n    'ytick.major.width':2.0,\n    'ytick.minor.width':1.5,\n    'ytick.direction':'in', \n    'ytick.minor.visible':True,\n    'ytick.right':True\n}\n\nplt.rcParams.update(**settings)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 5,
                "codebleu": {
                    "codebleu": 0.4204545454545454,
                    "ngram_match_score": 0,
                    "weighted_ngram_match_score": 0,
                    "syntax_match_score": 0.6818181818181818,
                    "dataflow_match_score": 0.0
                },
                "codebertscore": {
                    "precision": 0.8660003542900085,
                    "recall": 0.8377900719642639,
                    "F1": 0.8516616821289062,
                    "F3": 0.8405281901359558
                },
                "codebertscore_rescaled": {
                    "precision": 0.7320007085800171,
                    "recall": 0.6755801439285278,
                    "F1": 0.7033233642578125,
                    "F3": 0.6810563802719116
                }
            },
            {
                "ind": 11,
                "gen_code": "# Initialize SPARCL Client\nsparcl = SparclClient()",
                "true_code": "## Load the SPARCL client for data discovery and spectral access\n\nclient = SparclClient()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 56,
                "codebleu": {
                    "codebleu": 0.514574013118527,
                    "ngram_match_score": 0.028439110602897978,
                    "weighted_ngram_match_score": 0.029856941871210404,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9097020030021667,
                    "recall": 0.8462897539138794,
                    "F1": 0.8768509030342102,
                    "F3": 0.8522303700447083
                },
                "codebertscore_rescaled": {
                    "precision": 0.8194040060043335,
                    "recall": 0.6925795078277588,
                    "F1": 0.7537018060684204,
                    "F3": 0.7044607400894165
                }
            },
            {
                "ind": 13,
                "gen_code": "# Display the SPARCL client representation to confirm its setup\nclient",
                "true_code": "client",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 16,
                "codebleu": {
                    "codebleu": 0.5344427576307549,
                    "ngram_match_score": 0.018850319022747353,
                    "weighted_ngram_match_score": 0.11892071150027214,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.6233011484146118,
                    "recall": 0.8182379007339478,
                    "F1": 0.7075890898704529,
                    "F3": 0.7934237122535706
                },
                "codebertscore_rescaled": {
                    "precision": 0.24660229682922363,
                    "recall": 0.6364758014678955,
                    "F1": 0.41517817974090576,
                    "F3": 0.5868474245071411
                }
            },
            {
                "ind": 16,
                "gen_code": "# Data discovery constraints for SDSS DR16\nsdss_cons = {\n    'datasetgroup': 'SDSS_BOSS',\n    'sparcl_ds': 'sdss_dr16',\n    'specprimary': True,\n    'spectype': 'GALAXY',\n    'redshift': [0.1, 0.15],\n    'ra': [208.4, 210.2],\n    'dec': [4.8, 6.4]\n}\n\n# Data discovery constraints for DESI EDR\ndesi_cons = {\n    'datasetgroup': 'DESI',\n    'sparcl_ds': 'desi_edr',\n    'specprimary': True,\n    'spectype': 'GALAXY',\n    'redshift': [0.1, 0.15],\n    'ra': [208.4, 210.2],\n    'dec': [4.8, 6.4]\n}",
                "true_code": "## The outfields that are required as output from SPARCL\nout = ['sparcl_id', 'specid', 'ra', 'dec', 'redshift'] \n\n## Constraints\n## SPECTYPE = 'GALAXY'\n## 208.4 <= RA <= 210.2\n## 4.8 <= DEC <= 6.4\n## 0.1 <= Redshift <= 0.15\n## SPECPRIMARY = True -- consider only primary spectra\n## \"datasetgroup\" denotes the required survey (SDSS_BOSS for SDSS-DR16 (SDSS+BOSS data), and DESI for DESI EDR data (will be updated with future releases))\n\nsdss_cons = {'spectype':['GALAXY'], 'ra':[208.4, 210.2], 'dec':[4.8, 6.4], 'specprimary': [True], 'datasetgroup': ['SDSS_BOSS'], 'redshift': [0.1, 0.15]}\ndesi_cons = {'spectype':['GALAXY'], 'ra':[208.4, 210.2], 'dec':[4.8, 6.4], 'specprimary': [True], 'datasetgroup': ['DESI'], 'redshift': [0.1, 0.15]} ",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 10,
                "codebleu": {
                    "codebleu": 0.3492108363710905,
                    "ngram_match_score": 0.014895813121729,
                    "weighted_ngram_match_score": 0.01878963762579082,
                    "syntax_match_score": 0.6,
                    "dataflow_match_score": 0.7631578947368421
                },
                "codebertscore": {
                    "precision": 0.8822838664054871,
                    "recall": 0.8318946361541748,
                    "F1": 0.8563486337661743,
                    "F3": 0.8366730809211731
                },
                "codebertscore_rescaled": {
                    "precision": 0.7645677328109741,
                    "recall": 0.6637892723083496,
                    "F1": 0.7126972675323486,
                    "F3": 0.6733461618423462
                }
            },
            {
                "ind": 18,
                "gen_code": "## Query using SPARCL client\nrec_sdss = client.find(scopes=sdss_cons, outfields=out, limit=5000)\nrec_desi = client.find(scopes=desi_cons, outfields=out, limit=5000)",
                "true_code": "rec_sdss = client.find(outfields=out, constraints=sdss_cons, limit = 5000)\nrec_desi = client.find(outfields=out, constraints=desi_cons, limit = 5000)",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 63,
                "codebleu": {
                    "codebleu": 0.49278444944285177,
                    "ngram_match_score": 0.039530883746698414,
                    "weighted_ngram_match_score": 0.04271802513581977,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0.8888888888888888
                },
                "codebertscore": {
                    "precision": 0.8810797929763794,
                    "recall": 0.9352076053619385,
                    "F1": 0.9073371887207031,
                    "F3": 0.9294974207878113
                },
                "codebertscore_rescaled": {
                    "precision": 0.7621595859527588,
                    "recall": 0.870415210723877,
                    "F1": 0.8146743774414062,
                    "F3": 0.8589948415756226
                }
            },
            {
                "ind": 20,
                "gen_code": "ra_sdss = np.array([item['ra'] for item in rec_sdss])\ndec_sdss = np.array([item['dec'] for item in rec_sdss])\n\nra_desi = np.array([item['ra'] for item in rec_desi])\ndec_desi = np.array([item['dec'] for item in rec_desi])",
                "true_code": "ra_sdss = np.array([rec['ra'] for rec in rec_sdss.records])\ndec_sdss = np.array([rec['dec'] for rec in rec_sdss.records])\n\nra_desi = np.array([rec['ra'] for rec in rec_desi.records])\ndec_desi = np.array([rec['dec'] for rec in rec_desi.records])",
                "error_ind": 20,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.2401931643603304,
                    "ngram_match_score": 0.03378206595264862,
                    "weighted_ngram_match_score": 0.036746689049648486,
                    "syntax_match_score": 0.3902439024390244,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.9672940969467163,
                    "recall": 0.9452654719352722,
                    "F1": 0.9561529755592346,
                    "F3": 0.9474231004714966
                },
                "codebertscore_rescaled": {
                    "precision": 0.9345881938934326,
                    "recall": 0.8905309438705444,
                    "F1": 0.9123059511184692,
                    "F3": 0.8948462009429932
                }
            },
            {
                "ind": 22,
                "gen_code": "plt.figure(figsize=(10, 8))\nplt.scatter(ra_desi, dec_desi, color='grey', label='DESI EDR', alpha=0.5)\nplt.scatter(ra_sdss, dec_sdss, color='red', marker='x', label='SDSS DR16', alpha=0.7)\nplt.xlabel('R.A. (degrees)')\nplt.ylabel('Declination (degrees)')\nplt.title('Comparison of SDSS DR16 and DESI EDR Source Distribution')\nplt.gca().invert_xaxis() # Invert x-axis for astronomical convention\nplt.legend()\nplt.grid(True)\nplt.show()",
                "true_code": "## Overlap of sources\n\nplt.figure(figsize = (8,8))\n\nplt.suptitle('Sky Positions of Galaxies with SDSS and DESI Spectra', fontsize = 20)\n\nplt.scatter(ra_desi, dec_desi, color = 'grey', marker = 'o', s = 50, alpha = 0.8, lw = 2.0, label = 'DESI EDR')\nplt.scatter(ra_sdss, dec_sdss, color = 'r', marker = 'X', s = 50, label = 'SDSS DR16')\nplt.gca().invert_xaxis()\nplt.xlabel('R.A. [deg]')\nplt.ylabel('Dec. [deg]')\nplt.legend(loc = 'upper right')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 13,
                "codebleu": {
                    "codebleu": 0.4112412241686543,
                    "ngram_match_score": 0.010233931157371616,
                    "weighted_ngram_match_score": 0.01250874329502322,
                    "syntax_match_score": 0.7333333333333333,
                    "dataflow_match_score": 0.8888888888888888
                },
                "codebertscore": {
                    "precision": 0.8927546143531799,
                    "recall": 0.8665971755981445,
                    "F1": 0.8794814944267273,
                    "F3": 0.8691437244415283
                },
                "codebertscore_rescaled": {
                    "precision": 0.7855092287063599,
                    "recall": 0.7331943511962891,
                    "F1": 0.7589629888534546,
                    "F3": 0.7382874488830566
                }
            },
            {
                "ind": 25,
                "gen_code": "## Common Targets\ncoords_desi = SkyCoord(ra=ra_desi*u.deg, dec=dec_desi*u.deg)\ncoords_sdss = SkyCoord(ra=ra_sdss*u.deg, dec=dec_sdss*u.deg)\n\nidx_desi, idx_sdss, _, _ = search_around_sky(coords_desi, coords_sdss, seplimit=0.5*u.arcsec)",
                "true_code": "## Find common sources between SDSS and DESI\n\ncat_desi = SkyCoord(ra = ra_desi*u.deg, dec = dec_desi*u.deg)\ncat_sdss = SkyCoord(ra = ra_sdss*u.deg, dec = dec_sdss*u.deg)\n\nii_desi, ii_sdss, _, _ = search_around_sky(cat_desi, cat_sdss, 0.5*u.arcsec)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 54,
                "codebleu": {
                    "codebleu": 0.43791799572872947,
                    "ngram_match_score": 0.03023414579168269,
                    "weighted_ngram_match_score": 0.033342599027996946,
                    "syntax_match_score": 0.8214285714285714,
                    "dataflow_match_score": 0.8666666666666667
                },
                "codebertscore": {
                    "precision": 0.9193463921546936,
                    "recall": 0.9276309013366699,
                    "F1": 0.923470139503479,
                    "F3": 0.9267958998680115
                },
                "codebertscore_rescaled": {
                    "precision": 0.8386927843093872,
                    "recall": 0.8552618026733398,
                    "F1": 0.846940279006958,
                    "F3": 0.853591799736023
                }
            },
            {
                "ind": 27,
                "gen_code": "## Retrieve the records of common sources\ndesi_common = rec_desi[ii_desi]\nsdss_common = rec_sdss[ii_sdss]",
                "true_code": "desi_common = [rec_desi.records[ii] for ii in ii_desi]\nsdss_common = [rec_sdss.records[ii] for ii in ii_sdss]",
                "error_ind": 27,
                "direct_match": false,
                "fuzzy_match": 59,
                "codebleu": {
                    "codebleu": 0.0820834137888598,
                    "ngram_match_score": 0.043026488932731095,
                    "weighted_ngram_match_score": 0.03530716622270816,
                    "syntax_match_score": 0.0,
                    "dataflow_match_score": 0.25
                },
                "codebertscore": {
                    "precision": 0.8671693801879883,
                    "recall": 0.8524389863014221,
                    "F1": 0.8597411513328552,
                    "F3": 0.8538894653320312
                },
                "codebertscore_rescaled": {
                    "precision": 0.7343387603759766,
                    "recall": 0.7048779726028442,
                    "F1": 0.7194823026657104,
                    "F3": 0.7077789306640625
                }
            },
            {
                "ind": 29,
                "gen_code": "t_desi_common = Table(rows=desi_common, names=out)\nt_sdss_common = Table(rows=sdss_common, names=out)",
                "true_code": "t_desi_common = Table(desi_common)\nt_sdss_common = Table(sdss_common)",
                "error_ind": 29,
                "direct_match": false,
                "fuzzy_match": 81,
                "codebleu": {
                    "codebleu": 0.21795789203173788,
                    "ngram_match_score": 0.08307018474412793,
                    "weighted_ngram_match_score": 0.12209471671615688,
                    "syntax_match_score": 0.0,
                    "dataflow_match_score": 0.6666666666666666
                },
                "codebertscore": {
                    "precision": 0.9061667919158936,
                    "recall": 0.9783260822296143,
                    "F1": 0.9408648610115051,
                    "F3": 0.9705971479415894
                },
                "codebertscore_rescaled": {
                    "precision": 0.8123335838317871,
                    "recall": 0.9566521644592285,
                    "F1": 0.8817297220230103,
                    "F3": 0.9411942958831787
                }
            },
            {
                "ind": 31,
                "gen_code": "t_common = hstack([t_desi_common, t_sdss_common], table_names=['desi', 'sdss'])\nt_common",
                "true_code": "## Combining the two tables into a single table\n\nt_comb = hstack([t_desi_common, t_sdss_common], table_names=['desi', 'sdss'])",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 71,
                "codebleu": {
                    "codebleu": 0.5855184247776315,
                    "ngram_match_score": 0.19605997334125028,
                    "weighted_ngram_match_score": 0.2460137257692754,
                    "syntax_match_score": 0.9,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9585162401199341,
                    "recall": 0.8669518828392029,
                    "F1": 0.9104377031326294,
                    "F3": 0.8753135204315186
                },
                "codebertscore_rescaled": {
                    "precision": 0.9170324802398682,
                    "recall": 0.7339037656784058,
                    "F1": 0.8208754062652588,
                    "F3": 0.7506270408630371
                }
            },
            {
                "ind": 33,
                "gen_code": "num_unique_sdss_specid = len(set(t_comb['specid_sdss']))\nprint(f\"Number of unique SDSS specid: {num_unique_sdss_specid}\")\n\nnum_unique_desi_specid = len(set(t_comb['specid_desi']))\nprint(f\"Number of unique DESI specid: {num_unique_desi_specid}\")",
                "true_code": "print ('Number of unique SDSS objects: ', len(np.unique(t_comb['specid_sdss'])))\nprint ('Number of unique DESI objects: ', len(np.unique(t_comb['specid_desi'])))",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 36,
                "codebleu": {
                    "codebleu": 0.31003145813127997,
                    "ngram_match_score": 0.08991396351259592,
                    "weighted_ngram_match_score": 0.1023857820560022,
                    "syntax_match_score": 0.34782608695652173,
                    "dataflow_match_score": 0.7
                },
                "codebertscore": {
                    "precision": 0.8983981609344482,
                    "recall": 0.9221862554550171,
                    "F1": 0.9101368188858032,
                    "F3": 0.9197509288787842
                },
                "codebertscore_rescaled": {
                    "precision": 0.7967963218688965,
                    "recall": 0.8443725109100342,
                    "F1": 0.8202736377716064,
                    "F3": 0.8395018577575684
                }
            },
            {
                "ind": 35,
                "gen_code": "## Identifying the SDSS specid that has multiple correspondences in DESI\nunique_sdss, counts = np.unique(t_comb['specid_sdss'], return_counts=True)\n# Getting the specid which has count more than 1\nduplicate_sdss_specid = unique_sdss[counts > 1]\n\n## Removing objects corresponding to the duplicate specid\nmask = ~np.isin(t_comb['specid_sdss'], duplicate_sdss_specid)\nt_comb_unique = t_comb[mask]",
                "true_code": "## This suggests that one SDSS object has been selected as two DESI objects.\n## We remove that particular object from our selection\n\nsdss_ids_unique, n_counts = np.unique(t_comb['specid_sdss'].data, return_counts = True)\nsdss_id_repeated = sdss_ids_unique[n_counts > 1]\n\n## Removing this particular object\nt_comb_unique = t_comb[~(t_comb['specid_sdss'].data == sdss_id_repeated)]",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 39,
                "codebleu": {
                    "codebleu": 0.2955549196813853,
                    "ngram_match_score": 0.07312765319030126,
                    "weighted_ngram_match_score": 0.07181132378085396,
                    "syntax_match_score": 0.4583333333333333,
                    "dataflow_match_score": 0.5789473684210527
                },
                "codebertscore": {
                    "precision": 0.8666801452636719,
                    "recall": 0.8592163324356079,
                    "F1": 0.8629320859909058,
                    "F3": 0.8599568605422974
                },
                "codebertscore_rescaled": {
                    "precision": 0.7333602905273438,
                    "recall": 0.7184326648712158,
                    "F1": 0.7258641719818115,
                    "F3": 0.7199137210845947
                }
            },
            {
                "ind": 37,
                "gen_code": "z_desi = t_comb_unique['redshift_desi'].data\nz_sdss = t_comb_unique['redshift_sdss'].data",
                "true_code": "z_desi = t_comb_unique['redshift_desi']\nz_sdss = t_comb_unique['redshift_sdss']",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 94,
                "codebleu": {
                    "codebleu": 0.29715846946918956,
                    "ngram_match_score": 0.12209471671615688,
                    "weighted_ngram_match_score": 0.12209471671615688,
                    "syntax_match_score": 0.4444444444444444,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.9679422974586487,
                    "recall": 0.9938308000564575,
                    "F1": 0.9807156920433044,
                    "F3": 0.9911798238754272
                },
                "codebertscore_rescaled": {
                    "precision": 0.9358845949172974,
                    "recall": 0.987661600112915,
                    "F1": 0.9614313840866089,
                    "F3": 0.9823596477508545
                }
            },
            {
                "ind": 39,
                "gen_code": "print('Number of redshift samples from SDSS:', len(z_sdss))\nprint('Number of redshift samples from DESI:', len(z_desi))",
                "true_code": "len(z_desi), len(z_sdss)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 22,
                "codebleu": {
                    "codebleu": 0.41666666666666663,
                    "ngram_match_score": 0,
                    "weighted_ngram_match_score": 0,
                    "syntax_match_score": 0.6666666666666666,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.7843104600906372,
                    "recall": 0.905780017375946,
                    "F1": 0.8406801819801331,
                    "F3": 0.8919658064842224
                },
                "codebertscore_rescaled": {
                    "precision": 0.5686209201812744,
                    "recall": 0.8115600347518921,
                    "F1": 0.6813603639602661,
                    "F3": 0.7839316129684448
                }
            },
            {
                "ind": 41,
                "gen_code": "## Plotting redshift comparison\n\nplt.figure(figsize = (8,8))\n\nplt.scatter(z_sdss, z_desi, color = 'darkblue', marker = 'o', s = 80, alpha = 0.6)\nplt.plot([0.1, 0.15], [0.1, 0.15], 'r--', lw = 2.0, label = '1-to-1 line') ## Identity line\nplt.xlabel('SDSS Redshift', fontsize=16)\nplt.ylabel('DESI Redshift', fontsize=16)\nplt.title('Redshift Comparison between SDSS and DESI', fontsize=18)\nplt.legend()\nplt.grid(True)\nplt.xlim(0.1, 0.15)\nplt.ylim(0.1, 0.15)\nplt.show()",
                "true_code": "# Comparison of redshifts\nplt.figure(figsize = (6,6))\nplt.suptitle('Redshift Comparison')\n\nplt.scatter(z_sdss, z_desi, edgecolors = 'k', marker = 'o', s = 100, lw = 3.0, facecolors = 'none')\nplt.plot([0.1, 0.15], [0.1,0.15], ls = ':', color = 'r', lw = 2.0)\nplt.xlabel('$z_{spec}$ (SDSS)')\nplt.ylabel('$z_{spec}$ (DESI)')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 30,
                "codebleu": {
                    "codebleu": 0.4712094713781605,
                    "ngram_match_score": 0.10247347873772344,
                    "weighted_ngram_match_score": 0.137919962330474,
                    "syntax_match_score": 0.6444444444444445,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8672490119934082,
                    "recall": 0.9056608080863953,
                    "F1": 0.8860387206077576,
                    "F3": 0.9016671180725098
                },
                "codebertscore_rescaled": {
                    "precision": 0.7344980239868164,
                    "recall": 0.8113216161727905,
                    "F1": 0.7720774412155151,
                    "F3": 0.8033342361450195
                }
            },
            {
                "ind": 44,
                "gen_code": "## Formulate a query to select galaxies with non-zero [OII] measurements\nquery = \"\"\"\nSELECT gal.specobjid, gal.ra, gal.dec, elp.* \nFROM specObj gal \nJOIN emissionLinesPort elp ON gal.specobjid = elp.specobjid \nWHERE gal.spectype = 'GALAXY'\nAND gal.ra BETWEEN 208.4 AND 210.2\nAND gal.dec BETWEEN 4.8 AND 6.4\nAND elp.oii_3726_flux > 0\nAND elp.oii_3728_flux > 0\nAND gal.z BETWEEN 0.1 AND 0.15\n\"\"\"\n\nprint(query)",
                "true_code": "## Query to access galaxies with non-zero [OII] measurements\nquery = \"\"\"\nSELECT specobjid as specid_sdss, \nflux_oii_3726, flux_oii_3726_err,\nflux_oii_3728, flux_oii_3728_err\nFROM sdss_dr12.emissionlinesport\nWHERE (ra >= 208.4) AND (ra <= 210.2) AND (dec >= 4.8) AND (dec <= 6.4) \nAND (flux_oii_3726_err != 0) AND (flux_oii_3728_err != 0)\n\"\"\"",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 30,
                "codebleu": {
                    "codebleu": 0.5246102980814882,
                    "ngram_match_score": 0.15025638878646094,
                    "weighted_ngram_match_score": 0.198184803539492,
                    "syntax_match_score": 0.75,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8009578585624695,
                    "recall": 0.8753347396850586,
                    "F1": 0.8364962339401245,
                    "F3": 0.8672811985015869
                },
                "codebertscore_rescaled": {
                    "precision": 0.601915717124939,
                    "recall": 0.7506694793701172,
                    "F1": 0.672992467880249,
                    "F3": 0.7345623970031738
                }
            },
            {
                "ind": 46,
                "gen_code": "## Accessing the data from Data Lab\nt_em = qc.query(sql=query, fmt='table')",
                "true_code": "t_em = qc.query(sql = query, fmt = 'table')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 66,
                "codebleu": {
                    "codebleu": 0.5246507655574181,
                    "ngram_match_score": 0.03986357128268015,
                    "weighted_ngram_match_score": 0.05873949094699214,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8469291925430298,
                    "recall": 0.9530637264251709,
                    "F1": 0.8968673944473267,
                    "F3": 0.9412680268287659
                },
                "codebertscore_rescaled": {
                    "precision": 0.6938583850860596,
                    "recall": 0.9061274528503418,
                    "F1": 0.7937347888946533,
                    "F3": 0.8825360536575317
                }
            },
            {
                "ind": 48,
                "gen_code": "# Join the tables to get sources with [OII] measurements\nt_oii_comb = join(t_comb_unique, t_em, keys='specid_sdss', join_type='inner')",
                "true_code": "## Find sources from the common SDSS and DESI catalog that has [OII] flux\n## This part will change with SPARCL as well\n\nt_oii_comb = join(t_comb_unique, t_em, keys = ['specid_sdss'])",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 54,
                "codebleu": {
                    "codebleu": 0.2815381012459736,
                    "ngram_match_score": 0.07589828807225131,
                    "weighted_ngram_match_score": 0.09192078357830977,
                    "syntax_match_score": 0.125,
                    "dataflow_match_score": 0.8333333333333334
                },
                "codebertscore": {
                    "precision": 0.8898846507072449,
                    "recall": 0.8194624781608582,
                    "F1": 0.8532229065895081,
                    "F3": 0.8259991407394409
                },
                "codebertscore_rescaled": {
                    "precision": 0.7797693014144897,
                    "recall": 0.6389249563217163,
                    "F1": 0.7064458131790161,
                    "F3": 0.6519982814788818
                }
            },
            {
                "ind": 50,
                "gen_code": "print('Total number of entries in the combined table with [OII] measurements:', len(t_oii_comb))\nprint('Number of unique SDSS objects with [OII] measurements:', len(np.unique(t_oii_comb['specid_sdss'])))\nprint('Number of unique DESI objects with [OII] measurements:', len(np.unique(t_oii_comb['specid_desi'])))",
                "true_code": "len(np.unique(t_oii_comb['specid_sdss'])), len(np.unique(t_oii_comb['specid_desi']))",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 43,
                "codebleu": {
                    "codebleu": 0.46875,
                    "ngram_match_score": 0,
                    "weighted_ngram_match_score": 0,
                    "syntax_match_score": 0.875,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8076059818267822,
                    "recall": 0.9332197904586792,
                    "F1": 0.8658809065818787,
                    "F3": 0.9189268946647644
                },
                "codebertscore_rescaled": {
                    "precision": 0.6152119636535645,
                    "recall": 0.8664395809173584,
                    "F1": 0.7317618131637573,
                    "F3": 0.8378537893295288
                }
            },
            {
                "ind": 53,
                "gen_code": "## Extracting the unique sparcl_id of galaxies with available SDSS DR16 spectra\nids_sdss = list(np.unique(t_oii_comb['sparcl_id_sdss']))\n\n## Extracting the unique sparcl_id of galaxies with available DESI EDR spectra\nids_desi = list(np.unique(t_oii_comb['sparcl_id_desi']))",
                "true_code": "## Unique identifiers for SDSS and DESI\nids_sdss = [str(idx) for idx in t_oii_comb['sparcl_id_sdss'].data]\nids_desi = [str(idx) for idx in t_oii_comb['sparcl_id_desi'].data]",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 7,
                "codebleu": {
                    "codebleu": 0.2073509608132196,
                    "ngram_match_score": 0.021479380274235616,
                    "weighted_ngram_match_score": 0.02596957576059776,
                    "syntax_match_score": 0.21052631578947367,
                    "dataflow_match_score": 0.5714285714285714
                },
                "codebertscore": {
                    "precision": 0.8465697765350342,
                    "recall": 0.8628641963005066,
                    "F1": 0.8546392917633057,
                    "F3": 0.861206591129303
                },
                "codebertscore_rescaled": {
                    "precision": 0.6931395530700684,
                    "recall": 0.7257283926010132,
                    "F1": 0.7092785835266113,
                    "F3": 0.722413182258606
                }
            },
            {
                "ind": 55,
                "gen_code": "## Columns to retrieve\nsout = ['wavelength', 'flux', 'ivar', 'model', 'sparcl_id']\n\n## Retrieve SDSS and DESI spectra\nspec_sdss = client.retrieve(ids=ids_sdss, outfields=sout)\nspec_desi = client.retrieve(ids=ids_desi, outfields=sout)",
                "true_code": "## Use client.retrive for spectra\n## This retrieves all the 89 spectra at once\n\nsel = ['wavelength', 'flux', 'ivar', 'model', 'sparcl_id']\n\nspec_sdss = client.retrieve(uuid_list=ids_sdss, include = sel)\nspec_desi = client.retrieve(uuid_list=ids_desi, include = sel)",
                "error_ind": 55,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.5888222422415678,
                    "ngram_match_score": 0.1778303910800541,
                    "weighted_ngram_match_score": 0.1774585778862168,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.874245285987854,
                    "recall": 0.8535038828849792,
                    "F1": 0.863750159740448,
                    "F3": 0.8555335998535156
                },
                "codebertscore_rescaled": {
                    "precision": 0.748490571975708,
                    "recall": 0.7070077657699585,
                    "F1": 0.727500319480896,
                    "F3": 0.7110671997070312
                }
            },
            {
                "ind": 57,
                "gen_code": "# Reordering the spectra records to match the original order of identifiers\nspec_sdss_dict = {str(spec['sparcl_id']): spec for spec in spec_sdss}\nspec_desi_dict = {str(spec['sparcl_id']): spec for spec in spec_desi}\n\n# Use dictionary to create ordered lists based on sparcl_id\nspec_sdss_ordered = [spec_sdss_dict[idx] for idx in ids_sdss]\nspec_desi_ordered = [spec_desi_dict[idx] for idx in ids_desi]",
                "true_code": "## Reorder the records to match the original table\n\nres_sdss = spec_sdss.reorder(ids_sdss)\nres_desi = spec_desi.reorder(ids_desi)",
                "error_ind": 57,
                "direct_match": false,
                "fuzzy_match": 5,
                "codebleu": {
                    "codebleu": 0.21559068387965744,
                    "ngram_match_score": 0.07372935016702208,
                    "weighted_ngram_match_score": 0.28863338535160765,
                    "syntax_match_score": 0.0,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.7750686407089233,
                    "recall": 0.8852875232696533,
                    "F1": 0.826519787311554,
                    "F3": 0.8728747367858887
                },
                "codebertscore_rescaled": {
                    "precision": 0.5501372814178467,
                    "recall": 0.7705750465393066,
                    "F1": 0.6530395746231079,
                    "F3": 0.7457494735717773
                }
            },
            {
                "ind": 59,
                "gen_code": "def get_restframe_spectra(sparcl_rec, z, rest_frame=True):\n    '''Extract the rest-frame wavelength, flux, error, and model spectra \n    from a SPARCL record. The rest frame spectra is computed based on \n    https://astrosparcl.datalab.noirlab.edu/sparc/docs#Rest-Frame\n    \n    Inputs\n    ------\n    sparcl_rec (SPARCL response). \n    z: redshift information for a source\n    \n    Outputs\n    -------\n    The rest frame wavelength, flux, ivar (used to model errors), and model\n    spectra.'''\n\n    rest_frame_factor = 1.0\n    if rest_frame:\n        rest_frame_factor = 1.0 / (1.0 + z)\n\n    wave = np.array(sparcl_rec['wavelength']) * rest_frame_factor \n    flux = np.array(sparcl_rec['flux'])\n    ivar = np.array(sparcl_rec['ivar'])\n    err = np.where(ivar > 0.0, 1.0/np.sqrt(ivar), 0.0)\n    model = np.array(sparcl_rec['model'])\n\n    return wave, flux, err, model",
                "true_code": "def get_restframe_spectra(sparcl_rec, z, rest_frame = True):\n    \"\"\"\n    Function to extract the spectra from a given SPARCL record\n    \n    Parameters\n    ----------\n    sparcl_rec : dict\n        SPARCL record of a given object\n        \n    z : float\n        Redshift of the object\n        \n    rest_frame : bool\n        Whether or not to return the rest-frame spectra.\n        Default is True.\n        \n    Returns \n    -------\n    wavelength : array\n        Wavelength array of the spectra. \n        Returns the rest-frame values if rest_frame = True\n    \n    flux : array\n        Flux array of the spectra. \n        Returns the rest-frame values if rest_frame = True\n        \n    ivar : array\n        Inverse variance array of the spectra. \n        Returns the rest-frame values if rest_frame = True\n    \"\"\"\n    \n    wavelength = sparcl_rec.wavelength\n    flux = sparcl_rec.flux\n    ivar = sparcl_rec.ivar\n    \n    if (rest_frame == True):\n        wavelength = wavelength/(1+z)\n        flux = flux*(1+z)\n        ivar = ivar/((1+z)**2)\n    \n    return (wavelength, flux, ivar)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 12,
                "codebleu": {
                    "codebleu": 0.17693933374147852,
                    "ngram_match_score": 0.018574667689253057,
                    "weighted_ngram_match_score": 0.020714198808192585,
                    "syntax_match_score": 0.13513513513513514,
                    "dataflow_match_score": 0.5333333333333333
                },
                "codebertscore": {
                    "precision": 0.8139139413833618,
                    "recall": 0.8390703201293945,
                    "F1": 0.8263006806373596,
                    "F3": 0.8364849090576172
                },
                "codebertscore_rescaled": {
                    "precision": 0.6278278827667236,
                    "recall": 0.6781406402587891,
                    "F1": 0.6526013612747192,
                    "F3": 0.6729698181152344
                }
            },
            {
                "ind": 61,
                "gen_code": "# Calculate [OII] flux and its error\nflux_oii = t_oii_comb['flux_oii_3726'] + t_oii_comb['flux_oii_3728']\nflux_oii_err = np.sqrt(t_oii_comb['flux_oii_3726_err']**2 + t_oii_comb['flux_oii_3728_err']**2)\n\n# Calculate SNR\nsnr_oii = flux_oii / flux_oii_err\n\n# Identify index of maximum SNR source\nmax_snr_index = np.argmax(snr_oii)\n\n# Extract redshift for the selected galaxy\nz_max_snr = t_oii_comb['redshift_sdss'][max_snr_index]\n\n# Get DESI and SDSS spectra for the source with the highest [OII] SNR\ndesi_spec_max_snr = res_desi.records[max_snr_index]\nsdss_spec_max_snr = res_sdss.records[max_snr_index]\n\n# Extract rest-frame spectra\nwavelength_desi, flux_desi, ivar_desi = get_restframe_spectra(desi_spec_max_snr, z_max_snr, rest_frame=True)\nwavelength_sdss, flux_sdss, ivar_sdss = get_restframe_spectra(sdss_spec_max_snr, z_max_snr, rest_frame=True)",
                "true_code": "total_oii_flux = t_oii_comb['flux_oii_3726'].data + t_oii_comb['flux_oii_3728'].data\ntotal_oii_err = np.sqrt((t_oii_comb['flux_oii_3726_err'].data**2)+(t_oii_comb['flux_oii_3728_err'].data**2))\noii_snr = total_oii_flux/total_oii_err\n\n## Select source with the maximum [OII] flux SNR \nii = np.argmax(oii_snr)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 26,
                "codebleu": {
                    "codebleu": 0.26578307343933916,
                    "ngram_match_score": 0.016902809137097567,
                    "weighted_ngram_match_score": 0.06622948462025904,
                    "syntax_match_score": 0.5,
                    "dataflow_match_score": 0.48
                },
                "codebertscore": {
                    "precision": 0.785022497177124,
                    "recall": 0.9237592816352844,
                    "F1": 0.8487588763237,
                    "F3": 0.9077171683311462
                },
                "codebertscore_rescaled": {
                    "precision": 0.570044994354248,
                    "recall": 0.8475185632705688,
                    "F1": 0.6975177526473999,
                    "F3": 0.8154343366622925
                }
            },
            {
                "ind": 62,
                "gen_code": "# Extract the redshift for the source\nz_max_snr = t_oii_comb['redshift_sdss'][ii]\n\n# Retrieve and store the spectra for the source with max [OII] SNR\nw_sdss, f_sdss, ivar_sdss = get_restframe_spectra(res_sdss.records[ii], z_max_snr, rest_frame=True)\nw_desi, f_desi, ivar_desi = get_restframe_spectra(res_desi.records[ii], z_max_snr, rest_frame=True)",
                "true_code": "lam_desi, flux_desi, ivar_desi = get_restframe_spectra(res_desi.records[ii], t_oii_comb['redshift_desi'].data[ii], rest_frame = True)\nlam_sdss, flux_sdss, ivar_sdss = get_restframe_spectra(res_sdss.records[ii], t_oii_comb['redshift_sdss'].data[ii], rest_frame = True)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 17,
                "codebleu": {
                    "codebleu": 0.3080464475851456,
                    "ngram_match_score": 0.043354502820145475,
                    "weighted_ngram_match_score": 0.09344667213582157,
                    "syntax_match_score": 0.48,
                    "dataflow_match_score": 0.6153846153846154
                },
                "codebertscore": {
                    "precision": 0.8457647562026978,
                    "recall": 0.9086859226226807,
                    "F1": 0.8760970830917358,
                    "F3": 0.9019755721092224
                },
                "codebertscore_rescaled": {
                    "precision": 0.6915295124053955,
                    "recall": 0.8173718452453613,
                    "F1": 0.7521941661834717,
                    "F3": 0.8039511442184448
                }
            },
            {
                "ind": 64,
                "gen_code": "## Calculate flux errors\nerr_sdss = 1/np.sqrt(ivar_sdss)\nerr_desi = 1/np.sqrt(ivar_desi)",
                "true_code": "err_sdss = np.sqrt(1/ivar_sdss)\nerr_desi = np.sqrt(1/ivar_desi)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 78,
                "codebleu": {
                    "codebleu": 0.2847651403361424,
                    "ngram_match_score": 0.06311969078225892,
                    "weighted_ngram_match_score": 0.12209471671615688,
                    "syntax_match_score": 0.15384615384615385,
                    "dataflow_match_score": 0.8
                },
                "codebertscore": {
                    "precision": 0.9189382791519165,
                    "recall": 0.9493188858032227,
                    "F1": 0.9338815808296204,
                    "F3": 0.9461907148361206
                },
                "codebertscore_rescaled": {
                    "precision": 0.837876558303833,
                    "recall": 0.8986377716064453,
                    "F1": 0.8677631616592407,
                    "F3": 0.8923814296722412
                }
            },
            {
                "ind": 66,
                "gen_code": "plt.figure(figsize = (10, 5))\nplt.plot(lam_desi, flux_desi, color='k', label='DESI EDR', lw=1.5)\nplt.plot(lam_sdss, flux_sdss, color='r', label='SDSS DR16', lw=1.5)\nplt.fill_between(lam_desi, flux_desi - err_desi, flux_desi + err_desi, color='k', alpha=0.3)\nplt.fill_between(lam_sdss, flux_sdss - err_sdss, flux_sdss + err_sdss, color='r', alpha=0.3)\n\nplt.xlim(3500, 9000)\nplt.ylim(-5, 30)\n\nplt.xlabel('Wavelength ($\\mathring{A}$)')\nplt.ylabel(r'Flux ($10^{-17} \\rm ~erg~cm^{-2}~s^{-1}~A^{-1}$)')\nplt.legend(loc='upper right')\nplt.title('Comparison of SDSS and DESI Spectra')\nplt.grid(False)\n",
                "true_code": "plt.figure(figsize = (20, 8))\n\nplt.plot(lam_desi, flux_desi, color = 'k', label = 'DESI-EDR')\nplt.plot(lam_sdss, flux_sdss, color = 'r', label = 'SDSS')\nplt.xlim([3600, 7000])\nplt.ylim([-5, 100])\nplt.xlabel('$\\lambda~[\\AA]$')\nplt.ylabel('$F_{\\lambda}~[10^{-17}~ergs~s^{-1}~cm^{-2}~{\\AA}^{-1}]$')\nplt.legend(loc = 'upper left')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 25,
                "codebleu": {
                    "codebleu": 0.4367653300732127,
                    "ngram_match_score": 0.012650662740918714,
                    "weighted_ngram_match_score": 0.022872196013470604,
                    "syntax_match_score": 0.7115384615384616,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8397145867347717,
                    "recall": 0.9084119200706482,
                    "F1": 0.8727133870124817,
                    "F3": 0.9010404944419861
                },
                "codebertscore_rescaled": {
                    "precision": 0.6794291734695435,
                    "recall": 0.8168238401412964,
                    "F1": 0.7454267740249634,
                    "F3": 0.8020809888839722
                }
            },
            {
                "ind": 68,
                "gen_code": "plt.figure(figsize = (10, 8))\n\nplt.plot(lam_desi, flux_desi, color='k', lw=2, label='DESI-EDR')\nplt.fill_between(lam_desi, flux_desi - err_desi, flux_desi + err_desi, color='grey', alpha=0.4)\nplt.plot(lam_sdss, flux_sdss, color='k', lw=2, ls='-', label='SDSS')\nplt.fill_between(lam_sdss, flux_sdss - err_sdss, flux_sdss + err_sdss, color='grey', alpha=0.4)\n\nplt.axvline(x=3726, color='r', ls='--')\nplt.axvline(x=3728, color='r', ls='--')\n\nplt.xlim([3700, 3750])\nplt.ylim([-5, 100])\nplt.xlabel('$\\lambda~[\\AA]$')\nplt.ylabel('$F_{\\lambda}~[10^{-17}~ergs~s^{-1}~cm^{-2}~\\AA^{-1}]$')\nplt.legend(loc='upper left')",
                "true_code": "fig, axs = plt.subplots(1,2,figsize = (20,6), sharex = True, sharey = True)\n\naxs[0].plot(lam_sdss, flux_sdss, color = 'k', lw = 2.0)\naxs[0].fill_between(lam_sdss, flux_sdss-err_sdss, flux_sdss+err_sdss, color = 'grey', alpha = 0.5)\naxs[1].plot(lam_desi, flux_desi, color = 'k', lw = 2.0)\naxs[1].fill_between(lam_desi, flux_desi-err_desi, flux_desi+err_desi, color = 'grey', alpha = 0.5)\naxs[0].axvline(3727.092, color = 'r', ls = ':')\naxs[0].axvline(3729.875, color = 'r', ls = ':')\naxs[1].axvline(3727.092, color = 'r', ls = ':')\naxs[1].axvline(3729.875, color = 'r', ls = ':')\n\naxs[0].set(xlabel = '$\\lambda~[\\AA]$', ylabel = '$F_{\\lambda}~[10^{-17}~ergs~s^{-1}~cm^{-2}~{\\AA}^{-1}]$', title = 'SDSS')\naxs[1].set(xlim = [3710,3745], ylim = [-2,100], title = 'DESI-EDR', xlabel = '$\\lambda~[\\AA]$', ylabel = '$F_{\\lambda}~[10^{-17}~ergs~s^{-1}~cm^{-2}~{\\AA}^{-1}]$')\n\nplt.show()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 15,
                "codebleu": {
                    "codebleu": 0.19678828602224938,
                    "ngram_match_score": 0.0017017825698707096,
                    "weighted_ngram_match_score": 0.0024005140614996707,
                    "syntax_match_score": 0.4830508474576271,
                    "dataflow_match_score": 0.3
                },
                "codebertscore": {
                    "precision": 0.8899234533309937,
                    "recall": 0.855043351650238,
                    "F1": 0.8721348643302917,
                    "F3": 0.8584078550338745
                },
                "codebertscore_rescaled": {
                    "precision": 0.7798469066619873,
                    "recall": 0.7100867033004761,
                    "F1": 0.7442697286605835,
                    "F3": 0.716815710067749
                }
            }
        ],
        "result_summary": {
            "direct_match": 0.0,
            "fuzzy_match": 36.333333333333336,
            "codebleu": 0.36918864325938455,
            "syntax_match_score": 0.5704211959543791,
            "codebertscore": 0.8743224501609802,
            "codebertscore_rescaled": 0.7486449003219604,
            "code_success": 0.8,
            "total_code_cell_count": 30
        }
    },
    {
        "notebook": {
            "assignment": "02_GettingStartedWithDataLab_assignment.ipynb",
            "reference": "/Users/saj2765/Desktop/astro/rare-packages-code-gen/notebook_analysis/notebooks-latest/01_GettingStartedWithDataLab/02_GettingStartedWithDataLab.ipynb",
            "prefix": "gettingstarted_2"
        },
        "model": {
            "model": "gpt-4o",
            "library": "OA"
        },
        "result": [
            {
                "ind": 1,
                "gen_code": "metadata = {\n    'nbid': 'astroinfo_01',\n    'author': {\n        'name': 'Jane Doe',\n        'email': 'jane.doe@example.com'\n    },\n    'version': '20231005',\n    'datasets': [\n        'sloan_dss_dr7', \n        'gaia_dr2',\n        'panstarrs_dr1'\n    ],\n    'keywords': ['astronomy', 'astroinformatics', 'datasets', 'Sloan Digital Sky Survey', 'Gaia', 'Pan-STARRS']\n}",
                "true_code": "__nbid__ = '0002'\n__author__ = 'Knut Olsen <knut.olsen@noirlab.edu>, Robert Nikutta <robert.nikutta@noirlab.edu>'\n__version__ = '20240603' # yyyymmdd\n__datasets__ = ['smash_dr1', 'des_dr1']\n__keywords__ = ['tutorial', 'query', 'image cutout', 'globular cluster', 'SIA']",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 18,
                "codebleu": {
                    "codebleu": 0.27843886169693643,
                    "ngram_match_score": 0.005834347180338519,
                    "weighted_ngram_match_score": 0.006471824245088331,
                    "syntax_match_score": 0.43478260869565216,
                    "dataflow_match_score": 0.6666666666666666
                },
                "codebertscore": {
                    "precision": 0.7219843864440918,
                    "recall": 0.7302757501602173,
                    "F1": 0.7261063456535339,
                    "F3": 0.7294380068778992
                },
                "codebertscore_rescaled": {
                    "precision": 0.4439687728881836,
                    "recall": 0.46055150032043457,
                    "F1": 0.45221269130706787,
                    "F3": 0.45887601375579834
                }
            },
            {
                "ind": 10,
                "gen_code": "# Check current authentication status\ncurrent_user = ac.whoAmI()\n\n# If needed, log in with credentials (uncomment if you have credentials and need to log in)\n# token = getpass('Enter Personal Access Token: ')\n# ac.login(token)\n\ncurrent_user",
                "true_code": "#token = ac.login(input(\"Enter user name: (+ENTER) \"),getpass(\"Enter password: (+ENTER) \"))\nac.whoAmI()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.4071374610764008,
                    "ngram_match_score": 0.006132910803680854,
                    "weighted_ngram_match_score": 0.022416933501922302,
                    "syntax_match_score": 0.6,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.7579985857009888,
                    "recall": 0.8192381858825684,
                    "F1": 0.7874295115470886,
                    "F3": 0.81267249584198
                },
                "codebertscore_rescaled": {
                    "precision": 0.5159971714019775,
                    "recall": 0.6384763717651367,
                    "F1": 0.5748590230941772,
                    "F3": 0.62534499168396
                }
            },
            {
                "ind": 12,
                "gen_code": "schema_info = qc.schema('')\nprint(schema_info)",
                "true_code": "print(qc.schema())",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 44,
                "codebleu": {
                    "codebleu": 0.2857142857142857,
                    "ngram_match_score": 0,
                    "weighted_ngram_match_score": 0,
                    "syntax_match_score": 0.14285714285714285,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.8677884936332703,
                    "recall": 0.935193657875061,
                    "F1": 0.900231122970581,
                    "F3": 0.9279856085777283
                },
                "codebertscore_rescaled": {
                    "precision": 0.7355769872665405,
                    "recall": 0.8703873157501221,
                    "F1": 0.8004622459411621,
                    "F3": 0.8559712171554565
                }
            },
            {
                "ind": 14,
                "gen_code": "print(qc.schema('smash_dr1'))",
                "true_code": "print(qc.schema('smash_dr1'))",
                "error_ind": null,
                "direct_match": true,
                "fuzzy_match": 100,
                "codebleu": {
                    "codebleu": 0.5553941064735807,
                    "ngram_match_score": 0.1778279410038923,
                    "weighted_ngram_match_score": 0.04374848489043043,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 1.000000238418579,
                    "recall": 1.000000238418579,
                    "F1": 1.000000238418579,
                    "F3": 1.000000238418579
                },
                "codebertscore_rescaled": {
                    "precision": 1.0000004768371582,
                    "recall": 1.0000004768371582,
                    "F1": 1.0000004768371582,
                    "F3": 1.0000004768371582
                }
            },
            {
                "ind": 16,
                "gen_code": "print(qc.schema('smash_dr1.object'))",
                "true_code": "print(qc.schema('smash_dr1.object'))",
                "error_ind": null,
                "direct_match": true,
                "fuzzy_match": 100,
                "codebleu": {
                    "codebleu": 0.5553941064735807,
                    "ngram_match_score": 0.1778279410038923,
                    "weighted_ngram_match_score": 0.04374848489043043,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 1.0,
                    "recall": 1.0,
                    "F1": 1.0,
                    "F3": 1.0
                },
                "codebertscore_rescaled": {
                    "precision": 1.0,
                    "recall": 1.0,
                    "F1": 1.0,
                    "F3": 1.0
                }
            },
            {
                "ind": 18,
                "gen_code": "query = \"SELECT * FROM tbl_stat WHERE schema = 'smash_dr1' AND tbl_name = 'object'\"\nqc.query(sql=query)",
                "true_code": "#query = \"SELECT COUNT(ra) FROM phat_v2.phot_mod\" # SLOW\nquery = \"SELECT * FROM tbl_stat WHERE schema='smash_dr1' AND tbl_name='object'\" # Retrieve useful stats, quickly\n<a class=\"anchor\" id=\"resources\"></a>\n# Further resources and references\n* This notebook is [available on GitHub](https://github.com/astro-datalab/notebooks-latest/blob/058d6a71dbdd7f4f19a38f5ec6f78cd9b107113c/01_GettingStartedWithDataLab/02_GettingStartedWithDataLab.ipynb)\n* An in-depth [notebook on Simple Image Access](https://github.com/astro-datalab/notebooks-latest/blob/058d6a71dbdd7f4f19a38f5ec6f78cd9b107113c/04_HowTos/SiaService/How_to_use_the_Simple_Image_Access_service.ipynb)\n* Info about the [globular cluster NGC 288](https://en.wikipedia.org/wiki/NGC_288)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 21,
                "codebleu": {
                    "codebleu": 0.08232155122523198,
                    "ngram_match_score": 0.03164858609725974,
                    "weighted_ngram_match_score": 0.10551049709908171,
                    "syntax_match_score": 0.14084507042253522,
                    "dataflow_match_score": 0.05128205128205128
                },
                "codebertscore": {
                    "precision": 0.8788881897926331,
                    "recall": 0.5461829304695129,
                    "F1": 0.6736979484558105,
                    "F3": 0.5676723122596741
                },
                "codebertscore_rescaled": {
                    "precision": 0.7577763795852661,
                    "recall": 0.09236586093902588,
                    "F1": 0.3473958969116211,
                    "F3": 0.13534462451934814
                }
            },
            {
                "ind": 20,
                "gen_code": "result = qc.query(sql=query)\nprint(result)",
                "true_code": "info = qc.query(sql=query) # by default the result is a CSV formatted string\n<a class=\"anchor\" id=\"resources\"></a>\n# Further resources and references\n* This notebook is [available on GitHub](https://github.com/astro-datalab/notebooks-latest/blob/058d6a71dbdd7f4f19a38f5ec6f78cd9b107113c/01_GettingStartedWithDataLab/02_GettingStartedWithDataLab.ipynb)\n* An in-depth [notebook on Simple Image Access](https://github.com/astro-datalab/notebooks-latest/blob/058d6a71dbdd7f4f19a38f5ec6f78cd9b107113c/04_HowTos/SiaService/How_to_use_the_Simple_Image_Access_service.ipynb)\n* Info about the [globular cluster NGC 288](https://en.wikipedia.org/wiki/NGC_288)",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.06923187513026154,
                    "ngram_match_score": 8.536555814535279e-06,
                    "weighted_ngram_match_score": 0.009222696268963913,
                    "syntax_match_score": 0.14864864864864866,
                    "dataflow_match_score": 0.11904761904761904
                },
                "codebertscore": {
                    "precision": 0.7776637673377991,
                    "recall": 0.5075926780700684,
                    "F1": 0.6142532229423523,
                    "F3": 0.5258548259735107
                },
                "codebertscore_rescaled": {
                    "precision": 0.5553275346755981,
                    "recall": 0.015185356140136719,
                    "F1": 0.2285064458847046,
                    "F3": 0.051709651947021484
                }
            },
            {
                "ind": 22,
                "gen_code": "query = \"SELECT * FROM smash_dr1.object LIMIT 10\"\nresult = qc.query(sql=query) # By default the result is a CSV formatted string\nprint(result)",
                "true_code": "query = \"SELECT * FROM smash_dr1.object LIMIT 10\"\nresult = qc.query(sql=query) # by default the result is a CSV formatted string",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 94,
                "codebleu": {
                    "codebleu": 0.8976445347557238,
                    "ngram_match_score": 0.8232490471721702,
                    "weighted_ngram_match_score": 0.867329091850725,
                    "syntax_match_score": 0.9,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9791349172592163,
                    "recall": 0.992416262626648,
                    "F1": 0.9857308864593506,
                    "F3": 0.9910719990730286
                },
                "codebertscore_rescaled": {
                    "precision": 0.9582698345184326,
                    "recall": 0.9848325252532959,
                    "F1": 0.9714617729187012,
                    "F3": 0.9821439981460571
                }
            },
            {
                "ind": 24,
                "gen_code": "# Check the type of the result\nprint(type(result))\n\n# Print the first 1000 characters of the result\nprint(result[:1000])",
                "true_code": "print(type(result))\nprint(result[:1000]) # print just the first 1000 characters of the returned string",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 58,
                "codebleu": {
                    "codebleu": 0.6785027846402394,
                    "ngram_match_score": 0.2928298013714698,
                    "weighted_ngram_match_score": 0.4211813371894875,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9165582656860352,
                    "recall": 0.9183143377304077,
                    "F1": 0.9174354076385498,
                    "F3": 0.9181385040283203
                },
                "codebertscore_rescaled": {
                    "precision": 0.8331165313720703,
                    "recall": 0.8366286754608154,
                    "F1": 0.8348708152770996,
                    "F3": 0.8362770080566406
                }
            },
            {
                "ind": 26,
                "gen_code": "import pandas as pd\n\ndf = convert(result)\ndf.head()",
                "true_code": "df = convert(result,'pandas')\ndf.head()",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 67,
                "codebleu": {
                    "codebleu": 0.2607084684018323,
                    "ngram_match_score": 0.06500593260343691,
                    "weighted_ngram_match_score": 0.1778279410038923,
                    "syntax_match_score": 0.4,
                    "dataflow_match_score": 0.4
                },
                "codebertscore": {
                    "precision": 0.8602780699729919,
                    "recall": 0.9088155031204224,
                    "F1": 0.8838809728622437,
                    "F3": 0.9037166237831116
                },
                "codebertscore_rescaled": {
                    "precision": 0.7205561399459839,
                    "recall": 0.8176310062408447,
                    "F1": 0.7677619457244873,
                    "F3": 0.8074332475662231
                }
            },
            {
                "ind": 28,
                "gen_code": "# Execute the query and specify to return the result directly as a pandas DataFrame \ndf = qc.query(sql=query, fmt='pandas')\ndf.head()",
                "true_code": "query = \"SELECT * FROM smash_dr1.object LIMIT 10\"\ndf = qc.query(sql=query,fmt='pandas')\ndf.head()",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 56,
                "codebleu": {
                    "codebleu": 0.34488855528208906,
                    "ngram_match_score": 0.024218026052883736,
                    "weighted_ngram_match_score": 0.0428361950754725,
                    "syntax_match_score": 0.8125,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.8256681561470032,
                    "recall": 0.8270284533500671,
                    "F1": 0.8263477683067322,
                    "F3": 0.8268921375274658
                },
                "codebertscore_rescaled": {
                    "precision": 0.6513363122940063,
                    "recall": 0.6540569067001343,
                    "F1": 0.6526955366134644,
                    "F3": 0.6537842750549316
                }
            },
            {
                "ind": 30,
                "gen_code": "# Coordinates for NGC 288 and Field of View\nra = 13.19\ndec = -26.59\nfov = 13/60  # in degrees\n\n# SIA query to find images overlapping with specified region\nresults = svc.search(pos=(ra, dec), size=fov)\nresults",
                "true_code": "# NGC 288 (a globular cluster)\nra = 13.19     # in decimal degrees\ndec = -26.59   # in decimal degrees\n\nfov = 13/60  # image cutout field of view (in degrees; here 13 arminutes = 0.22 degrees)\n\nimgTable = svc.search((ra,dec), (fov/np.cos(dec*np.pi/180), fov), verbosity=2).to_table()  # uses declination correction",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 31,
                "codebleu": {
                    "codebleu": 0.3184480090656679,
                    "ngram_match_score": 0.10851857142040569,
                    "weighted_ngram_match_score": 0.11213336822390843,
                    "syntax_match_score": 0.4444444444444444,
                    "dataflow_match_score": 0.6086956521739131
                },
                "codebertscore": {
                    "precision": 0.8398211598396301,
                    "recall": 0.8103326559066772,
                    "F1": 0.8248133659362793,
                    "F3": 0.8131880164146423
                },
                "codebertscore_rescaled": {
                    "precision": 0.6796423196792603,
                    "recall": 0.6206653118133545,
                    "F1": 0.6496267318725586,
                    "F3": 0.6263760328292847
                }
            },
            {
                "ind": 32,
                "gen_code": "# The imgTable is already converted to an Astropy Table using .to_table() method.\n# Now let's print its type and examine the contents.\nprint(type(imgTable))\nprint(imgTable)",
                "true_code": "# boolean selection for just g-band images\nsel0 = imgTable['obs_bandpass'] == 'g'\n\n# logically add selections for 'Stack' and 'image' product type\nsel = sel0 & ((imgTable['proctype'] == 'Stack') & (imgTable['prodtype'] == 'image')) # basic selection\n\n# filter the above results table\nTable = imgTable[sel] # select\nTable",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 27,
                "codebleu": {
                    "codebleu": 0.049777787884207586,
                    "ngram_match_score": 0.004725104822792953,
                    "weighted_ngram_match_score": 0.0068860467140373785,
                    "syntax_match_score": 0.0,
                    "dataflow_match_score": 0.1875
                },
                "codebertscore": {
                    "precision": 0.7371334433555603,
                    "recall": 0.714525043964386,
                    "F1": 0.7256532311439514,
                    "F3": 0.7167232632637024
                },
                "codebertscore_rescaled": {
                    "precision": 0.4742668867111206,
                    "recall": 0.429050087928772,
                    "F1": 0.45130646228790283,
                    "F3": 0.4334465265274048
                }
            },
            {
                "ind": 34,
                "gen_code": "# boolean selection for just g-band images\nsel_g_band = imgTable['obs_bandpass'] == 'g'\n\n# logically add selections for 'Stack' and 'image' product type\nsel_type = (imgTable['proctype'] == 'Stack') & (imgTable['prodtype'] == 'image') \n\n# apply filters for selection\nselected_images = imgTable[sel_g_band & sel_type]\n\n# display the filtered table\nselected_images",
                "true_code": "row = Table[0]\nurl = row['access_url'] # get the download URL\nprint(url)",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.12428746996497592,
                    "ngram_match_score": 0.005528849622582646,
                    "weighted_ngram_match_score": 0.024088562704853513,
                    "syntax_match_score": 0.18181818181818182,
                    "dataflow_match_score": 0.2857142857142857
                },
                "codebertscore": {
                    "precision": 0.6605371832847595,
                    "recall": 0.708931028842926,
                    "F1": 0.6838790774345398,
                    "F3": 0.7037748694419861
                },
                "codebertscore_rescaled": {
                    "precision": 0.32107436656951904,
                    "recall": 0.41786205768585205,
                    "F1": 0.3677581548690796,
                    "F3": 0.40754973888397217
                }
            },
            {
                "ind": 36,
                "gen_code": "from astropy.utils.data import download_file\n\nimage_path = download_file(url, cache=True)\nprint(f\"Image successfully downloaded to {image_path}\")",
                "true_code": "gimage = io.fits.getdata(utils.data.download_file(url,cache=True,show_progress=False,timeout=120))",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 46,
                "codebleu": {
                    "codebleu": 0.11816999570890438,
                    "ngram_match_score": 0.01553712569276035,
                    "weighted_ngram_match_score": 0.10000000000000002,
                    "syntax_match_score": 0.07142857142857142,
                    "dataflow_match_score": 0.2857142857142857
                },
                "codebertscore": {
                    "precision": 0.7919422388076782,
                    "recall": 0.8033512234687805,
                    "F1": 0.7976058721542358,
                    "F3": 0.8021954894065857
                },
                "codebertscore_rescaled": {
                    "precision": 0.5838844776153564,
                    "recall": 0.606702446937561,
                    "F1": 0.5952117443084717,
                    "F3": 0.6043909788131714
                }
            },
            {
                "ind": 38,
                "gen_code": "from matplotlib.colors import PowerNorm\n\nplt.imshow(gimage, cmap='gray', norm=PowerNorm(0.5))\nplt.axis('off') # remove axes for a cleaner display\nplt.show()",
                "true_code": "fig = plt.subplots(figsize=(10,10))\nplt.imshow(np.arcsinh(gimage),cmap='gray',norm=matplotlib.colors.Normalize(vmin=0))\nplt.axis('off');",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 31,
                "codebleu": {
                    "codebleu": 0.1919642857142857,
                    "ngram_match_score": 0,
                    "weighted_ngram_match_score": 0,
                    "syntax_match_score": 0.39285714285714285,
                    "dataflow_match_score": 0.375
                },
                "codebertscore": {
                    "precision": 0.8571396470069885,
                    "recall": 0.8516625165939331,
                    "F1": 0.8543922901153564,
                    "F3": 0.8522071242332458
                },
                "codebertscore_rescaled": {
                    "precision": 0.714279294013977,
                    "recall": 0.7033250331878662,
                    "F1": 0.7087845802307129,
                    "F3": 0.7044142484664917
                }
            },
            {
                "ind": 40,
                "gen_code": "def download_deep_stack(ra, dec, fov, band):\n    # Perform the SIA query\n    imgTable = svc.search((ra, dec), (fov/np.cos(dec*np.pi/180), fov), verbosity=2).to_table()\n    \n    # Print the total number of image entries retrieved\n    print(f\"Total entries retrieved: {len(imgTable)}\")\n    \n    # Apply selection criteria: filter for the specific band and image type\n    band_selection = (imgTable['obs_bandpass'] == band)\n    type_selection = (imgTable['proctype'] == 'Stack') & (imgTable['prodtype'] == 'image')\n    selection = band_selection & type_selection\n    \n    # Filter the table\n    selected_images = imgTable[selection]\n    if len(selected_images) == 0:\n        print(f\"No {band}-band Stack images found.\")\n        return None\n    \n    # Pick the one with the longest exposure time\n    best_image = selected_images[np.argmax(selected_images['exptime'])]\n    \n    # Extract and print the access URL\n    url = best_image['access_url']\n    print(f\"Downloading image from: {url}\")\n    \n    # Downloading the image\n    try:\n        image_data = io.fits.getdata(utils.data.download_file(url, cache=True, show_progress=False, timeout=120))\n        return image_data\n    except Exception as e:\n        print(f\"Failed to download image: {e}\")\n        return None",
                "true_code": "# A function to download the deepest available stacked images\ndef download_deep_stack(ra,dec,fov=0.1,band='g'):\n    imgTable = svc.search((ra,dec), (fov/np.cos(dec*np.pi/180), fov), verbosity=2).to_table()\n    print(\"The full image list contains\", len(imgTable), \"entries\")\n\n    # apply image seletion criteria\n    sel0 = imgTable['obs_bandpass'] == band\n    sel = sel0 & ((imgTable['proctype'] == 'Stack') & (imgTable['prodtype'] == 'image')) # basic selection\n    Table = imgTable[sel] # select\n\n    # if more than one image matches our desired criteria\n    if (len(Table)>0):\n        row = Table[np.argmax(Table['exptime'].data.data.astype('float'))] # pick image with longest exposure time\n        url = row['access_url'] # get the download URL\n        print ('Downloading deepest stacked image...')\n        image = io.fits.getdata(utils.data.download_file(url,cache=True,show_progress=False,timeout=120))\n        print(url)\n\n    # if no images match our criteria\n    else:\n        print ('No image available.')\n        image = None\n        \n    print()\n    return image",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 18,
                "codebleu": {
                    "codebleu": 0.2983585805592939,
                    "ngram_match_score": 0.06720532796200308,
                    "weighted_ngram_match_score": 0.08001394806012631,
                    "syntax_match_score": 0.6306306306306306,
                    "dataflow_match_score": 0.4155844155844156
                },
                "codebertscore": {
                    "precision": 0.8607434630393982,
                    "recall": 0.8666743040084839,
                    "F1": 0.8636987209320068,
                    "F3": 0.8660775423049927
                },
                "codebertscore_rescaled": {
                    "precision": 0.7214869260787964,
                    "recall": 0.7333486080169678,
                    "F1": 0.7273974418640137,
                    "F3": 0.7321550846099854
                }
            },
            {
                "ind": 42,
                "gen_code": "rimage = download_deep_stack(ra, dec, fov, 'r')\niimage = download_deep_stack(ra, dec, fov, 'i')",
                "true_code": "rimage = download_deep_stack(ra,dec,fov,band='r')\niimage = download_deep_stack(ra,dec,fov,band='i')",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 92,
                "codebleu": {
                    "codebleu": 0.24243478034571253,
                    "ngram_match_score": 0.05094110796339642,
                    "weighted_ngram_match_score": 0.12209471671615688,
                    "syntax_match_score": 0.15384615384615385,
                    "dataflow_match_score": 0.6428571428571429
                },
                "codebertscore": {
                    "precision": 0.9846277236938477,
                    "recall": 0.9659510254859924,
                    "F1": 0.9751999974250793,
                    "F3": 0.9677867293357849
                },
                "codebertscore_rescaled": {
                    "precision": 0.9692554473876953,
                    "recall": 0.9319020509719849,
                    "F1": 0.9503999948501587,
                    "F3": 0.9355734586715698
                }
            },
            {
                "ind": 44,
                "gen_code": "color_image = make_lupton_rgb(iimage, rimage, gimage, stretch=0.5, Q=10)\n\nplt.figure(figsize=(10, 10))\nplt.imshow(color_image, origin='lower')\nplt.axis('off')\nplt.show()",
                "true_code": "color_image = make_lupton_rgb(iimage, rimage, gimage, stretch=100, Q=0.1)",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 59,
                "codebleu": {
                    "codebleu": 0.5474202329972018,
                    "ngram_match_score": 0.2891784933232572,
                    "weighted_ngram_match_score": 0.6147881529512643,
                    "syntax_match_score": 0.2857142857142857,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8044742345809937,
                    "recall": 0.9502487182617188,
                    "F1": 0.8713063597679138,
                    "F3": 0.9333361983299255
                },
                "codebertscore_rescaled": {
                    "precision": 0.6089484691619873,
                    "recall": 0.9004974365234375,
                    "F1": 0.7426127195358276,
                    "F3": 0.8666723966598511
                }
            },
            {
                "ind": 46,
                "gen_code": "plt.figure(figsize=(10,10))\nplt.imshow(color_image)\nplt.axis('off')\nplt.show()",
                "true_code": "fig = plt.figure(figsize=(10,10))\nplt.imshow(color_image)\nplt.axis('off');",
                "error_ind": 18,
                "direct_match": false,
                "fuzzy_match": 88,
                "codebleu": {
                    "codebleu": 0.3611182618118615,
                    "ngram_match_score": 0.13232169883599026,
                    "weighted_ngram_match_score": 0.11362193664674995,
                    "syntax_match_score": 0.8235294117647058,
                    "dataflow_match_score": 0.375
                },
                "codebertscore": {
                    "precision": 0.9701539278030396,
                    "recall": 0.969595730304718,
                    "F1": 0.9698746800422668,
                    "F3": 0.969651460647583
                },
                "codebertscore_rescaled": {
                    "precision": 0.9403078556060791,
                    "recall": 0.939191460609436,
                    "F1": 0.9397493600845337,
                    "F3": 0.939302921295166
                }
            }
        ],
        "result_summary": {
            "direct_match": 0.1,
            "fuzzy_match": 48.85,
            "codebleu": 0.33336779974611364,
            "syntax_match_score": 0.47819511465640485,
            "codebertscore": 0.8440768510103226,
            "codebertscore_rescaled": 0.6881537020206452,
            "code_success": 0.3,
            "total_code_cell_count": 20
        }
    },
    {
        "notebook": {
            "assignment": "StarClustersGaiaDR3_assignment.ipynb",
            "reference": "/Users/saj2765/Desktop/astro/rare-packages-code-gen/notebook_analysis/notebooks-latest/03_ScienceExamples/GalacticStructure/StarClustersGaiaDR3.ipynb",
            "prefix": "gaia_3"
        },
        "model": {
            "model": "gpt-4o",
            "library": "OA"
        },
        "result": [
            {
                "ind": 1,
                "gen_code": "# Notebook Metadata Initialization\n\n__nbid__ = \"Gaia_Star_Clusters_01\"\n__author__ = \"Your Name\"\n__version__ = \"1.0\"\n__datasets__ = [\"Gaia_DR3\"]\n__keywords__ = [\"Gaia\", \"Star Clusters\", \"Astronomy\", \"Proper Motion\", \"Color-Magnitude Diagram\"]",
                "true_code": "__nbid__ = '0017'\n__author__ = 'Leah Fulmer, Astro Data Lab Team <datalab@noirlab.edu>'\n__version__ = '20240603' # yyyymmdd\n__datasets__ = ['gaia_dr3']\n__keywords__ = ['star clusters', 'stars', 'proper motions', 'parallax', 'plot:cmd', 'plot:quiver', 'plot:animation']",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 17,
                "codebleu": {
                    "codebleu": 0.4260489974037165,
                    "ngram_match_score": 0.029149335476135012,
                    "weighted_ngram_match_score": 0.029213320805397576,
                    "syntax_match_score": 0.8333333333333334,
                    "dataflow_match_score": 0.8125
                },
                "codebertscore": {
                    "precision": 0.7858290672302246,
                    "recall": 0.7443003058433533,
                    "F1": 0.7645010948181152,
                    "F3": 0.7482545971870422
                },
                "codebertscore_rescaled": {
                    "precision": 0.5716581344604492,
                    "recall": 0.48860061168670654,
                    "F1": 0.5290021896362305,
                    "F3": 0.4965091943740845
                }
            },
            {
                "ind": 10,
                "gen_code": "# Uncomment these lines to log into Data Lab\n# token = ac.login(input(\"Enter your Data Lab username: \"), getpass(\"Enter your password: \"))\n# print(\"Token:\", token)\nprint(\"Current session user:\", ac.whoAmI())",
                "true_code": "#token = ac.login(input(\"Enter user name: (+ENTER) \"),getpass(\"Enter password: (+ENTER) \"))\nac.whoAmI()",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 30,
                "codebleu": {
                    "codebleu": 0.41592045472809863,
                    "ngram_match_score": 0.016275776313613193,
                    "weighted_ngram_match_score": 0.04740604259878138,
                    "syntax_match_score": 0.6,
                    "dataflow_match_score": 0
                },
                "codebertscore": {
                    "precision": 0.8039146065711975,
                    "recall": 0.8690915107727051,
                    "F1": 0.8352334499359131,
                    "F3": 0.8621021509170532
                },
                "codebertscore_rescaled": {
                    "precision": 0.607829213142395,
                    "recall": 0.7381830215454102,
                    "F1": 0.6704668998718262,
                    "F3": 0.7242043018341064
                }
            },
            {
                "ind": 12,
                "gen_code": "# Sample query to retrieve a row from the gaia_dr3.gaia_source table\nquery = \"\"\"\nSELECT * \nFROM gaia_dr3.gaia_source\nLIMIT 1\n\"\"\"\n\n# Execute the query\nresponse = qc.query(sql=query, fmt='pandas')\n\n# Convert response to DataFrame and display the column names\ndf = response.to_dataframe()\nprint(df.columns)",
                "true_code": "# Construct query as a string\nquery = \"SELECT * FROM gaia_dr3.gaia_source LIMIT 1\"\n\n# Submit query\nresponse = qc.query(sql=query, fmt='csv')\n\n# Convert output string to to a pandas DataFrame\ndf_init = convert(response,'pandas')\n\n# To view the available columns, include the following command\ndf_init.columns",
                "error_ind": 12,
                "direct_match": false,
                "fuzzy_match": 39,
                "codebleu": {
                    "codebleu": 0.43881736390841386,
                    "ngram_match_score": 0.14426480515468929,
                    "weighted_ngram_match_score": 0.1410798384488908,
                    "syntax_match_score": 0.6842105263157895,
                    "dataflow_match_score": 0.7857142857142857
                },
                "codebertscore": {
                    "precision": 0.8926568031311035,
                    "recall": 0.8759512305259705,
                    "F1": 0.884225070476532,
                    "F3": 0.8775936961174011
                },
                "codebertscore_rescaled": {
                    "precision": 0.785313606262207,
                    "recall": 0.7519024610519409,
                    "F1": 0.768450140953064,
                    "F3": 0.7551873922348022
                }
            },
            {
                "ind": 14,
                "gen_code": "def input_query(object_name, radius_deg):\n    # Get the sky coordinates of the object by name\n    coords = SkyCoord.from_name(object_name)\n    ra = coords.ra.deg\n    dec = coords.dec.deg\n    \n    # Construct the SQL query for a cone search around the given RA, Dec\n    sql_query = f\"\"\"\n    SELECT *\n    FROM gaia_dr3.gaia_source\n    WHERE CONTAINS(\n        POINT('ICRS', ra, dec),\n        CIRCLE('ICRS', {ra}, {dec}, {radius_deg})\n    ) = 1\n    \"\"\"\n    \n    # Submit the query\n    response = qc.query(sql=sql_query, fmt='csv')\n    \n    # Convert the response to a pandas DataFrame\n    df = convert(response, 'pandas')\n    \n    # Print the number of objects returned\n    print(f\"Number of objects returned: {len(df)}\")\n    \n    return df",
                "true_code": "# Write a query that returns all of the stars surrounding a particular object out to a particular radius \n\ndef input_query(object_name, radius_deg):\n    # SkyCoord.from_name outputs the coordinates of a particular object given its name as a string\n    c = SkyCoord.from_name(object_name)\n    \n    # Construct a Cone Search query\n    query = \"\"\"SELECT * FROM gaia_dr3.gaia_source \n            WHERE (q3c_radial_query(ra, dec, {0}, {1}, %s)\n            AND NOT parallax='Nan')\"\"\".format(c.ra.value,c.dec.value) % (radius_deg)\n    \n    # Submit the query\n    response = qc.query(sql=query, fmt='csv')\n    \n    # Convert the query to a pandas DataFrame\n    df = convert(response,'pandas')\n    \n    # Check the number of objects in your query\n    print(\"The query of %s contains %s objects.\" % (object_name, len(df)))\n    \n    # Return the output DataFrame\n    return df",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 32,
                "codebleu": {
                    "codebleu": 0.3702923643879975,
                    "ngram_match_score": 0.19639385483834526,
                    "weighted_ngram_match_score": 0.20027947868263693,
                    "syntax_match_score": 0.6511627906976745,
                    "dataflow_match_score": 0.43333333333333335
                },
                "codebertscore": {
                    "precision": 0.8792449831962585,
                    "recall": 0.8568797707557678,
                    "F1": 0.8679183125495911,
                    "F3": 0.8590649962425232
                },
                "codebertscore_rescaled": {
                    "precision": 0.7584899663925171,
                    "recall": 0.7137595415115356,
                    "F1": 0.7358366250991821,
                    "F3": 0.7181299924850464
                }
            },
            {
                "ind": 16,
                "gen_code": "# Define an object and radius of interest\nobject_name = \"Pleiades\"\nradius_deg = 1.5\n\n# Perform the query to obtain a DataFrame\nstar_cluster_df = input_query(object_name, radius_deg)",
                "true_code": "# Pick your favorite object!\n\n# Define an object\nobject_queried = \"NGC 6281\"\n\n# Define a radius\nradius = 0.5\n\n# Submit the function that returns a queried DataFrame\ndf = input_query(object_queried, radius)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 56,
                "codebleu": {
                    "codebleu": 0.5458650772732976,
                    "ngram_match_score": 0.09092735920162837,
                    "weighted_ngram_match_score": 0.0925329498915617,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8374001979827881,
                    "recall": 0.845055341720581,
                    "F1": 0.8412103652954102,
                    "F3": 0.8442835807800293
                },
                "codebertscore_rescaled": {
                    "precision": 0.6748003959655762,
                    "recall": 0.6901106834411621,
                    "F1": 0.6824207305908203,
                    "F3": 0.6885671615600586
                }
            },
            {
                "ind": 18,
                "gen_code": "def define_variables(df):\n    # Extract the required columns from the dataframe\n    ra = df['ra'].values\n    dec = df['dec'].values\n    pmra = df['pmra'].values\n    pmdec = df['pmdec'].values\n    parallax = df['parallax'].values\n    g_mag = df['phot_g_mean_mag'].values\n    bp_rp = df['bp_rp'].values\n    \n    # Return extracted variables\n    return ra, dec, pmra, pmdec, parallax, g_mag, bp_rp\n\n# Define variables using the queried DataFrame\nra, dec, pmra, pmdec, parallax, g_mag, bp_rp = define_variables(df)",
                "true_code": "# Define variables from DataFrame\n# Doing so within a function makes later re-definition very simple\ndef define_variables (df):\n    ra, dec = df[\"ra\"], df[\"dec\"]\n    ra_rad, dec_rad = np.radians(ra), np.radians(dec)\n    pmra, pmdec = df[\"pmra\"], df[\"pmdec\"]\n    parallax = df['parallax']\n    g, g_bp = df[\"phot_g_mean_mag\"], df[\"phot_g_mean_mag\"]-df[\"phot_bp_mean_mag\"]\n    return ra, dec, ra_rad, dec_rad, pmra, pmdec, parallax, g, g_bp\n\n# Submit the function that defines variables from the DataFrame\nra, dec, ra_rad, dec_rad, pmra, pmdec, parallax, g, g_bp = define_variables(df)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 16,
                "codebleu": {
                    "codebleu": 0.21355183457907273,
                    "ngram_match_score": 0.05400253667743173,
                    "weighted_ngram_match_score": 0.05673600628327145,
                    "syntax_match_score": 0.40384615384615385,
                    "dataflow_match_score": 0.33962264150943394
                },
                "codebertscore": {
                    "precision": 0.8801288604736328,
                    "recall": 0.8769719004631042,
                    "F1": 0.8785474896430969,
                    "F3": 0.8772865533828735
                },
                "codebertscore_rescaled": {
                    "precision": 0.7602577209472656,
                    "recall": 0.7539438009262085,
                    "F1": 0.7570949792861938,
                    "F3": 0.7545731067657471
                }
            },
            {
                "ind": 20,
                "gen_code": "def panel_plot(ra, dec, pmra, pmdec, g_bp, g):\n    # Create a figure and axis for three subplots\n    fig, axs = plt.subplots(1, 3, figsize=(18, 6))\n\n    # Plot 1: Spatial scatter plot\n    axs[0].scatter(ra, dec, s=1, c='k')\n    axs[0].set_xlabel('Right Ascension (deg)')\n    axs[0].set_ylabel('Declination (deg)')\n    axs[0].set_title('Spatial Distribution')\n\n    # Plot 2: Quiver plot for proper motions\n    quiver_scale = 1000  # Scale the proper motion vectors for visibility\n    axs[1].quiver(ra, dec, pmra, pmdec, scale=quiver_scale, color='b', alpha=0.5)\n    axs[1].set_xlabel('Right Ascension (deg)')\n    axs[1].set_ylabel('Declination (deg)')\n    axs[1].set_title('Proper Motion Vectors')\n\n    # Plot 3: Color-magnitude diagram\n    hb = axs[2].hexbin(g_bp, g, gridsize=100, cmap='Greys', bins='log')\n    axs[2].set_xlabel('G_BP - G (mag)')\n    axs[2].set_ylabel('G (mag)')\n    axs[2].set_title('Color-Magnitude Diagram')\n    axs[2].invert_yaxis()\n    plt.colorbar(hb, ax=axs[2], label='log(count)')\n\n    # Adjust layout\n    plt.tight_layout()\n    plt.show()\n\n# Generate the plots using the defined function\npanel_plot(ra, dec, pmra, pmdec, g_bp, g)",
                "true_code": "# Write a function that outputs spatial and color-magnitude plots for your sampled object\ndef panel_plot(ra, dec, pmra, pmdec, color, mag):\n    fig = plt.figure(figsize=(26,8))\n    \n    # A simple spatial plot\n    ax1 = fig.add_subplot(131)\n    ax1.scatter(ra, dec, marker='.', alpha= 1/np.power(len(df), 0.1))\n    ax1.set_title(\"Spatial Plot\",fontsize=10)\n    ax1.set_xlabel(\"Right Ascension\",fontsize=10)\n    ax1.set_ylabel(\"Declination\",fontsize=10)\n    \n    # A quiver plot (spatial plot with arrows that describe each object's proper motion)\n    ax2 = fig.add_subplot(132)\n    ax2.quiver(ra, dec, pmra, pmdec)\n    ax2.set_title(\"Proper Motions\",fontsize=10)\n    ax2.set_xlabel(\"Right Ascension\",fontsize=10)\n    ax2.set_ylabel(\"Declination\",fontsize=10)\n    \n    # A color-magnitude diagram that exhibits object density\n    ax3 = fig.add_subplot(133)\n    im3 = ax3.hexbin(g_bp, g, bins='log', cmap=plt.cm.viridis, mincnt=1)\n    ax3.set_ylim(max(g), min(g))\n    ax3.set_title(\"Color-Magnitude Diagram\",fontsize=10)\n    ax3.set_xlabel(\"Gaia G-BP Color\",fontsize=10)\n    ax3.set_ylabel(\"Gaia G Magnitude\",fontsize=10)\n    cb = plt.colorbar(im3,label='log(N)')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 6,
                "codebleu": {
                    "codebleu": 0.2434651242534577,
                    "ngram_match_score": 0.0457574711968342,
                    "weighted_ngram_match_score": 0.056846465150124134,
                    "syntax_match_score": 0.3902439024390244,
                    "dataflow_match_score": 0.4810126582278481
                },
                "codebertscore": {
                    "precision": 0.847774088382721,
                    "recall": 0.8353207111358643,
                    "F1": 0.8415013551712036,
                    "F3": 0.8365495800971985
                },
                "codebertscore_rescaled": {
                    "precision": 0.6955481767654419,
                    "recall": 0.6706414222717285,
                    "F1": 0.6830027103424072,
                    "F3": 0.673099160194397
                }
            },
            {
                "ind": 22,
                "gen_code": "# Write a function to convert variables into SkyCoord object format \ndef convert_to_skycoord(ra, dec, parallax, g, min_parallax=1, max_parallax=10):\n    # Calculate distance from parallax (remember parallax is given in milliarcseconds, thus the conversion)\n    distance = (parallax * u.mas).to(u.parsec, equivalencies=u.parallax())\n    \n    # Define a mask to filter on magnitude and parallax\n    mask = (parallax > min_parallax) & (parallax < max_parallax) & (g < 20)\n    \n    # Create a SkyCoord object for masked values\n    c = SkyCoord(ra=ra[mask], dec=dec[mask], distance=distance[mask], frame='icrs',\n                 representation_type='spherical')\n    \n    return g[mask], mask, c",
                "true_code": "# Convert variables to SkyCoord object and impose limits on output\n\ndef convert_to_skycoord (g, ra_rad, dec_rad, parallax, dist1, dist2):\n    # Define variables as as an numpy array and SkyCoord object\n    # Note: The SkyCoord object contains data for ra, dec, and parallax\n    mag = np.array(g)\n    scnow = SkyCoord(np.array(ra_rad) * u.rad, np.array(dec_rad) * u.rad, \n                 distance=(np.array(parallax)*u.mas).to(u.pc, u.parallax()))\n\n    # Create a \"mask\" with varying data thresholds (here depending on magnitude and distance)\n    msk = (mag < 16)  & (scnow.distance > dist1*u.pc) & (scnow.distance < dist2*u.pc)\n    \n    # Apply data thresholds to the given magnitude and SkyCoord objects\n    mag = mag[msk]\n    scnow = scnow[msk]\n    \n    # Print the new object count after applying data thresholds\n    print('After the thresholds are applied, this query contains %s objects.' % (len(scnow)))\n    \n    # Return the defined variables\n    return mag, msk, scnow\n    \nmag, msk, scnow = convert_to_skycoord(g, ra_rad, dec_rad, parallax, 1e2, 9e2)\n",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 12,
                "codebleu": {
                    "codebleu": 0.1841985635930442,
                    "ngram_match_score": 0.016343808384251052,
                    "weighted_ngram_match_score": 0.020168074063762805,
                    "syntax_match_score": 0.2972972972972973,
                    "dataflow_match_score": 0.40298507462686567
                },
                "codebertscore": {
                    "precision": 0.826790452003479,
                    "recall": 0.7664694786071777,
                    "F1": 0.7954881191253662,
                    "F3": 0.7721025943756104
                },
                "codebertscore_rescaled": {
                    "precision": 0.653580904006958,
                    "recall": 0.5329389572143555,
                    "F1": 0.5909762382507324,
                    "F3": 0.5442051887512207
                }
            },
            {
                "ind": 24,
                "gen_code": "# Build a new colormap to improve the readability of markers\nn = plt.Normalize(vmin=scnow.distance.value.min(), vmax=scnow.distance.value.max())\nc_m = cm.viridis\ns_m = cm.ScalarMappable(cmap=c_m, norm=n)\ns_m.set_array([])\n\n# Adjusts the magnitude scaling, so that less bright markers increase quadratically in size\ndef mag_to_size(mag):\n    return 2.0/np.sqrt(mag)",
                "true_code": "# Make a special version of the viridis colormap that goes to a darker yellow at the end. \n# This makes it easier to see small points on a white background.\nnewvhsv = colors.rgb_to_hsv(cm.viridis.colors)\nnewvhsv[:,-1] = np.minimum(newvhsv[:,-1], .88)\ndarker_vidiris = colors.ListedColormap(colors.hsv_to_rgb(newvhsv))\n\n# Define a function to represent magnitude with marker size and distance with marker color\n# Here purple will symbolize closer objects, and yellow will symbolize those further away\ndef mag_to_size(mag):\n    unity_rescaled_mag = (np.max(mag) - mag)/np.ptp(mag)\n    return 40*unity_rescaled_mag**2+2\n\n# Save these visualization arguments as 'scatkwargs'\nscatkwargs = dict(s=mag_to_size(mag), alpha=.9, c=scnow.distance, cmap=darker_vidiris)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 2,
                "codebleu": {
                    "codebleu": 0.18454750652039392,
                    "ngram_match_score": 0.004687801915236673,
                    "weighted_ngram_match_score": 0.007311747975862834,
                    "syntax_match_score": 0.32142857142857145,
                    "dataflow_match_score": 0.40476190476190477
                },
                "codebertscore": {
                    "precision": 0.7428773641586304,
                    "recall": 0.7130703330039978,
                    "F1": 0.7276687622070312,
                    "F3": 0.7159429788589478
                },
                "codebertscore_rescaled": {
                    "precision": 0.48575472831726074,
                    "recall": 0.4261406660079956,
                    "F1": 0.4553375244140625,
                    "F3": 0.4318859577178955
                }
            },
            {
                "ind": 26,
                "gen_code": "# Define a function that produces an animation in equatorial space\n# Use the amplitude variable to control the number of oscillations in your animation\n\n# Define amplitude parameters in units of lightyears\namplitude, step_size = 12., 1\n\n# This function defines the animated representation of the cone search\ndef animfunc(frame):\n    # Create a matrix to apply to celestial coordinates and calculate updated proper motion matrix\n    factor = amplitude * (frame - num_frames/2) / num_frames\n    proper_motion_matrix = matrix_utilities.rotation_matrix(factor * u.deg, \"x\")\n    \n    # Create new proper motion coordinates using the previous matrix\n    newpos = scnow.data.to_cartesian() + CartesianRepresentation(pmrad, pmdec)\n    newpos = newpos.transform(proper_motion_matrix)\n    \n    new_eq = SphericalRepresentation.from_cartesian(newpos)\n    \n    scat.set_offsets(np.array([new_eq.lon.to(u.deg) - ra_center, new_eq.lat.to(u.deg) - dec_center]).T)\n    return scat,\n\n# Create a centered visualization of the star cluster\n# Set coordinate centers for new quiver plot visualization\nra_center, dec_center = c.ra.degree, c.dec.degree\n\n# Create figure for animation\nfig, ax = plt.subplots(figsize=(10, 10))\nscat = ax.scatter(scnow.ra.degree - ra_center, scnow.dec.degree - dec_center, **scatkwargs)\n\n#gca means get current axis in matplotlib\nax.add_artist(ax.yaxis.set_major_formatter(plt.FuncFormatter(\"{0:.2f}\\N{DEGREE SIGN}\".format)))\n\nplt.xlim(-tol,tol)\nplt.ylim(-tol,tol)\nax.set_xlabel(\"Offset Right Ascension from \" + object_queried)\nax.set_ylabel(\"Offset Declination from \" + object_queried)\n\nanim = animation.FuncAnimation(\n    fig, animfunc, frames=num_frames, interval=200, blit=True)\n\n# Set number of frames\nnum_frames = 100\n\n# Render and display animation\nHTML(anim.to_jshtml())",
                "true_code": "# Write a function to animate the parallax of your sample\n\n# The amplitude describes the distance that markers will move in portraying parallax.\namplitude = 0.6*u.lightyear\nrepr0 = scnow.barycentrictrueecliptic.cartesian\n\ndef animfunc(phase, eclcart_to_spherical, centerstr, ylims, ax):\n    \n    # Converting from Cartesian to spherical coordinates\n    drepr = CartesianRepresentation([np.cos(phase),np.sin(phase),0]*amplitude)\n    rep = repr0 + drepr\n    srep = eclcart_to_spherical(rep)\n    \n    # Creating and defining plot aesthetics\n    ax.cla()\n    ax.set_title(f'Center={centerstr}, Earth Semimajor Axis={amplitude} \\n')\n    # ax.scatter(srep.lon.rad, 90-srep.lat.deg, **scatkwargs)\n    ax.scatter(80.2+srep.lon.rad, 90-srep.lat.deg, **scatkwargs)\n    ax.set_ylim(*ylims)\n    ax.set_yticks(np.linspace(*ax.get_ylim(), 5)[1:])\n    ax.set_yticklabels(['{}'.format(int(90-yl)) for yl in ax.get_yticks()])\n    ax.grid(alpha=0.5)",
                "error_ind": 26,
                "direct_match": false,
                "fuzzy_match": 3,
                "codebleu": {
                    "codebleu": 0.1773899298525999,
                    "ngram_match_score": 0.003778159448868435,
                    "weighted_ngram_match_score": 0.010033759375020934,
                    "syntax_match_score": 0.3548387096774194,
                    "dataflow_match_score": 0.3409090909090909
                },
                "codebertscore": {
                    "precision": 0.7327615022659302,
                    "recall": 0.7631383538246155,
                    "F1": 0.7476414442062378,
                    "F3": 0.7599877715110779
                },
                "codebertscore_rescaled": {
                    "precision": 0.46552300453186035,
                    "recall": 0.526276707649231,
                    "F1": 0.4952828884124756,
                    "F3": 0.5199755430221558
                }
            },
            {
                "ind": 28,
                "gen_code": "# Center animation visualization on sample object\n\n# Define a SkyCoord object with center given as equatorial coordinates\ncen = SkyCoord(ra[0], dec[0], unit=u.deg)\ncenterstr = cen.to_string('decimal')\ncen_cartesian_rep = cen.barycentrictrueecliptic.cartesian.represent_as(CartesianRepresentation)\n\ndef eclcart_to_spherical(rep):\n    \"\"\"Convert Cartesian to spherical coordinates centered on the object.\"\"\"\n    srepr = rep.represent_as(SphericalRepresentation)\n    return SphericalRepresentation((srepr.lon+cen_cartesian_rep.lon).wrap_at(360*u.deg),\n                                   srepr.lat, srepr.distance)\n\n# Calculate plot bounds\near_fov_offset = u.arcminute.to(u.degree, .1)\nylims = 90-180/np.pi*np.array([cen_cartesian_rep.lat+ear_fov_offset,\n                               cen_cartesian_rep.lat-ear_fov_offset])\n\n# Animation parameters\nfig, ax = plt.subplots(figsize=(8, 5))\nplt.close(fig)\n\n# Animate over a range of \"phase\" values to visually simulate parallax\nani = animation.FuncAnimation(fig, animfunc, frames=60, \n                              fargs=(eclcart_to_spherical, centerstr, ylims, ax),\n                              interval=100)\nHTML(ani.to_jshtml())",
                "true_code": "# Centering the visualization on a given object\ndef eclcart_to_spherical3(rep):\n    icrsrep = SkyCoord(scnow.barycentrictrueecliptic.realize_frame(rep)).icrs.cartesian   \n    rot1 = matrix_utilities.rotation_matrix(object_name.ra, 'z')\n    rot2 = matrix_utilities.rotation_matrix(90*u.deg-object_name.dec, 'y')\n    return icrsrep.transform(rot2 @ rot1).represent_as(SphericalRepresentation)",
                "error_ind": 28,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.27395843264607844,
                    "ngram_match_score": 0.0065766717524137425,
                    "weighted_ngram_match_score": 0.02657899615383719,
                    "syntax_match_score": 0.358974358974359,
                    "dataflow_match_score": 0.7037037037037037
                },
                "codebertscore": {
                    "precision": 0.6984676122665405,
                    "recall": 0.7926163077354431,
                    "F1": 0.7425696849822998,
                    "F3": 0.782074511051178
                },
                "codebertscore_rescaled": {
                    "precision": 0.39693522453308105,
                    "recall": 0.5852326154708862,
                    "F1": 0.4851393699645996,
                    "F3": 0.564149022102356
                }
            },
            {
                "ind": 30,
                "gen_code": "# Generate stationary visualizations for the chosen star cluster\npanel_plot(ra, dec, pmra, pmdec, g_bp, g)",
                "true_code": "# Call stationary plot\npanel_plot(scnow.ra, scnow.dec, pmra[msk], pmdec[msk], g_bp[msk], g[msk])",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 59,
                "codebleu": {
                    "codebleu": 0.26020437465175006,
                    "ngram_match_score": 0.015718877363021206,
                    "weighted_ngram_match_score": 0.025098621243978974,
                    "syntax_match_score": 0.0,
                    "dataflow_match_score": 0.0
                },
                "codebertscore": {
                    "precision": 0.8675872087478638,
                    "recall": 0.8240088224411011,
                    "F1": 0.8452367186546326,
                    "F3": 0.8281686305999756
                },
                "codebertscore_rescaled": {
                    "precision": 0.7351744174957275,
                    "recall": 0.6480176448822021,
                    "F1": 0.6904734373092651,
                    "F3": 0.6563372611999512
                }
            },
            {
                "ind": 32,
                "gen_code": "# Set up the figure for animation\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Initialize the animation\nbase_truth = plt.gca()\nanim = animation.FuncAnimation(fig=fig, \n                               func=animfunc, \n                               fargs=(eclcart_to_spherical3, f'{object_queried}', ax.get_ylim(), ax),\n                               frames=np.linspace(0, 2*np.pi, 50), \n                               interval=75)\n\n# Show the animation\nHTML(anim.to_jshtml())",
                "true_code": "# Call parallax animation\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(projection='polar')\nobject_name = SkyCoord.from_name(object_queried)\ncenterstr3 = object_queried\nylims3 = (0, radius)\n\nanim3 = animation.FuncAnimation(fig, animfunc, np.linspace(0, 2*np.pi, 30),\n                                fargs=(eclcart_to_spherical3, centerstr3, ylims3, ax), \n                                interval=50)\n\nplt.close(fig)\nHTML(anim3.to_html5_video())",
                "error_ind": 32,
                "direct_match": false,
                "fuzzy_match": 14,
                "codebleu": {
                    "codebleu": 0.2364834704330253,
                    "ngram_match_score": 0.01588436203293868,
                    "weighted_ngram_match_score": 0.01635904350868638,
                    "syntax_match_score": 0.4375,
                    "dataflow_match_score": 0.47619047619047616
                },
                "codebertscore": {
                    "precision": 0.8618909120559692,
                    "recall": 0.8422163724899292,
                    "F1": 0.8519400358200073,
                    "F3": 0.844143271446228
                },
                "codebertscore_rescaled": {
                    "precision": 0.7237818241119385,
                    "recall": 0.6844327449798584,
                    "F1": 0.7038800716400146,
                    "F3": 0.688286542892456
                }
            },
            {
                "ind": 34,
                "gen_code": "# Define the second object and radius\nsecond_object_queried = \"NGC 6752\"\nsecond_radius = 0.5\n\n# Obtain data by querying for the second object\ndf2 = input_query(second_object_queried, second_radius)\n\n# Define the variables for the new query\nra2, dec2, ra_rad2, dec_rad2, pmra2, pmdec2, parallax2, g2, g_bp2 = define_variables(df2)\n\n# Convert to SkyCoord\nmag2, msk2, scnow2 = convert_to_skycoord(g2, ra_rad2, dec_rad2, parallax2, 1e2, 9e2)\n\n# Visualize the new query with a stationary plot\npanel_plot(scnow2.ra, scnow2.dec, pmra2[msk2], pmdec2[msk2], g_bp2[msk2], g2[msk2])\n\n# Prepare for parallax animation\nfig2 = plt.figure(figsize=(8, 8))\nax2 = plt.subplot(projection='polar')\nobject_name2 = SkyCoord.from_name(second_object_queried)\ncenterstr3_2 = second_object_queried\nylims3_2 = (0, second_radius)\n\nanim3_2 = animation.FuncAnimation(fig2, animfunc, np.linspace(0, 2*np.pi, 30),\n                                  fargs=(eclcart_to_spherical3, centerstr3_2, ylims3_2, ax2), \n                                  interval=50)\n\nplt.close(fig2)\nHTML(anim3_2.to_html5_video())",
                "true_code": "# Pick your second-favorite object!\n\n# Define object and radius\nobject_queried = \"NGC 6397\"\nradius = 0.1\n\n# Submit query\ndf = input_query(object_queried, radius)",
                "error_ind": 32,
                "direct_match": false,
                "fuzzy_match": 9,
                "codebleu": {
                    "codebleu": 0.49540517384129323,
                    "ngram_match_score": 0.013518198833235058,
                    "weighted_ngram_match_score": 0.06810249653193788,
                    "syntax_match_score": 0.9,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.579574465751648,
                    "recall": 0.8579885959625244,
                    "F1": 0.6918211579322815,
                    "F3": 0.8186619877815247
                },
                "codebertscore_rescaled": {
                    "precision": 0.1591489315032959,
                    "recall": 0.7159771919250488,
                    "F1": 0.383642315864563,
                    "F3": 0.6373239755630493
                }
            },
            {
                "ind": 35,
                "gen_code": "# Define necessary variables\nra, dec, ra_rad, dec_rad, pmra, pmdec, parallax, g, g_bp = define_variables(df)\n\n# Convert to SkyCoord object with constraints\nmag, msk, scnow = convert_to_skycoord(g, ra_rad, dec_rad, parallax, 1e2, 9e2)\n\n# Call stationary plot\npanel_plot(scnow.ra, scnow.dec, pmra[msk], pmdec[msk], g_bp[msk], g[msk])\n\n# Prepare for parallax animation\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(projection='polar')\nobject_name = SkyCoord.from_name(object_queried)\ncenterstr3 = object_queried\nylims3 = (0, radius)\n\nanim3 = animation.FuncAnimation(fig, animfunc, np.linspace(0, 2*np.pi, 30),\n                                fargs=(eclcart_to_spherical3, centerstr3, ylims3, ax), \n                                interval=50)\n\nplt.close(fig)\nHTML(anim3.to_html5_video())",
                "true_code": "# Define variables\nra, dec, ra_rad, dec_rad, pmra, pmdec, parallax, g, g_bp = define_variables(df)\n\n# Apply thresholds\nmag, msk, scnow = convert_to_skycoord(g, ra_rad, dec_rad, parallax, 1e3, 3e3)\n\n# Define visualization parameters\nscatkwargs = dict(s=mag_to_size(mag), alpha=.9, c=scnow.distance, cmap=darker_vidiris)\namplitude = 0.6*u.lightyear\nrepr0 = scnow.barycentrictrueecliptic.cartesian",
                "error_ind": 32,
                "direct_match": false,
                "fuzzy_match": 27,
                "codebleu": {
                    "codebleu": 0.5113630322748577,
                    "ngram_match_score": 0.25183636329064685,
                    "weighted_ngram_match_score": 0.46434747312585734,
                    "syntax_match_score": 0.5,
                    "dataflow_match_score": 0.8292682926829268
                },
                "codebertscore": {
                    "precision": 0.747028112411499,
                    "recall": 0.820614755153656,
                    "F1": 0.7820942401885986,
                    "F3": 0.8126100301742554
                },
                "codebertscore_rescaled": {
                    "precision": 0.49405622482299805,
                    "recall": 0.641229510307312,
                    "F1": 0.5641884803771973,
                    "F3": 0.6252200603485107
                }
            },
            {
                "ind": 36,
                "gen_code": "# Stationary visualization for the second object\npanel_plot(scnow.ra, scnow.dec, pmra[msk], pmdec[msk], g_bp[msk], g[msk])\n\n# Animation for parallax effect on the second object\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(projection='polar')\nobject_name = SkyCoord.from_name(object_queried)\ncenterstr3 = object_queried\nylims3 = (0, radius)\n\nanim3 = animation.FuncAnimation(fig, animfunc, np.linspace(0, 2*np.pi, 30),\n                                fargs=(eclcart_to_spherical3, centerstr3, ylims3, ax), \n                                interval=50)\n\nplt.close(fig)\nHTML(anim3.to_html5_video())",
                "true_code": "# Call stationary plot\npanel_plot(scnow.ra, scnow.dec, pmra[msk], pmdec[msk], g_bp[msk], g[msk])",
                "error_ind": 32,
                "direct_match": false,
                "fuzzy_match": 25,
                "codebleu": {
                    "codebleu": 0.6313022433301533,
                    "ngram_match_score": 0.08792400740884215,
                    "weighted_ngram_match_score": 0.537284965911771,
                    "syntax_match_score": 0.9,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.6497073769569397,
                    "recall": 0.9235053062438965,
                    "F1": 0.7627807855606079,
                    "F3": 0.8861609697341919
                },
                "codebertscore_rescaled": {
                    "precision": 0.2994147539138794,
                    "recall": 0.847010612487793,
                    "F1": 0.5255615711212158,
                    "F3": 0.7723219394683838
                }
            },
            {
                "ind": 37,
                "gen_code": "# Call parallax animation for second object\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(projection='polar')\nobject_name = SkyCoord.from_name(object_queried)\ncenterstr3 = object_queried\nylims3 = (0, radius)\n\nanim3 = animation.FuncAnimation(fig, animfunc, np.linspace(0, 2*np.pi, 30),\n                                fargs=(eclcart_to_spherical3, centerstr3, ylims3, ax), \n                                interval=50)\n\nplt.close(fig)\nHTML(anim3.to_html5_video())",
                "true_code": "# Call parallax animation\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(projection='polar')\nobject_name = SkyCoord.from_name(object_queried)\ncenterstr3 = object_queried\nylims3 = (0, radius)\n\nanim3 = animation.FuncAnimation(fig, animfunc, np.linspace(0, 2*np.pi, 30),\n                                fargs=(eclcart_to_spherical3, centerstr3, ylims3, ax), \n                                interval=50)\n\nplt.close(fig)\nHTML(anim3.to_html5_video())",
                "error_ind": 32,
                "direct_match": false,
                "fuzzy_match": 98,
                "codebleu": {
                    "codebleu": 0.9570983014853847,
                    "ngram_match_score": 0.8749766281017177,
                    "weighted_ngram_match_score": 0.9534165778398209,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9856653809547424,
                    "recall": 0.9942257404327393,
                    "F1": 0.9899271130561829,
                    "F3": 0.9933630228042603
                },
                "codebertscore_rescaled": {
                    "precision": 0.9713307619094849,
                    "recall": 0.9884514808654785,
                    "F1": 0.9798542261123657,
                    "F3": 0.9867260456085205
                }
            }
        ],
        "result_summary": {
            "direct_match": 0.0,
            "fuzzy_match": 26.647058823529413,
            "codebleu": 0.38623013206839024,
            "syntax_match_score": 0.5666373908240955,
            "codebertscore": 0.8147238352719475,
            "codebertscore_rescaled": 0.629447670543895,
            "code_success": 0.5294117647058824,
            "total_code_cell_count": 17
        }
    },
    {
        "notebook": {
            "assignment": "DwarfGalaxiesInDelveDr2_assignment.ipynb",
            "reference": "/Users/saj2765/Desktop/astro/rare-packages-code-gen/notebook_analysis/notebooks-latest/03_ScienceExamples/DwarfGalaxies/DwarfGalaxiesInDelveDr2.ipynb",
            "prefix": "dwarfgalaxies_4"
        },
        "model": {
            "model": "gpt-4o",
            "library": "OA"
        },
        "result": [
            {
                "ind": 1,
                "gen_code": "# Project Metadata\n__nbid__ = \"explore_delve_dr2\"\n__author__ = \"Astronomy Research Group <astro_research@example.com>\"\n__version__ = \"20231010\"\n__datasets__ = [\"DELVE DR2\"]\n__keywords__ = [\"astronomy\", \"dwarf galaxies\", \"DELVE\", \"DR2\", \"astrophysics\"]",
                "true_code": "__nbid__ = '0007'\n__author__ = 'Jonah Medoff <jmedoff@uchicago.edu>, Alice Jacques <alice.jacques@noirlab.edu>'\n__version__ = '20240620' # yyyymmdd\n__datasets__ = ['delve_dr2']\n__keywords__ = ['science example', 'dwarf galaxies'] ",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 7,
                "codebleu": {
                    "codebleu": 0.4422639718432375,
                    "ngram_match_score": 0.03380403803967974,
                    "weighted_ngram_match_score": 0.03668725603183501,
                    "syntax_match_score": 0.7894736842105263,
                    "dataflow_match_score": 0.9090909090909091
                },
                "codebertscore": {
                    "precision": 0.7990573048591614,
                    "recall": 0.777638852596283,
                    "F1": 0.7882025837898254,
                    "F3": 0.7797288298606873
                },
                "codebertscore_rescaled": {
                    "precision": 0.5981146097183228,
                    "recall": 0.5552777051925659,
                    "F1": 0.5764051675796509,
                    "F3": 0.5594576597213745
                }
            },
            {
                "ind": 10,
                "gen_code": "# Set coordinates for query\nra, dec = 189.58, -40.89\n\n# Construct SQL query string\nquery = f\"\"\"\nSELECT ra, dec, mag_auto_g, mag_auto_r, mag_auto_i\nFROM delve_dr2.objects\nWHERE 1=CONTAINS(\n  POINT('ICRS', ra, dec),\n  CIRCLE('ICRS', {ra}, {dec}, 0.1)) \nAND mag_auto_g BETWEEN 14 AND 25 \nAND (mag_auto_g - mag_auto_r) BETWEEN -0.4 AND 0.4\n\"\"\"\n\n# Output the query string\nprint(query)",
                "true_code": "ra = 189.58\ndec = -40.89\n\n# Create the query string; SQL keyword capitalized for clarity\n\nquery =\\\n\"\"\"SELECT ra,dec,mag_auto_g,mag_auto_r,mag_auto_i\n   FROM delve_dr2.objects\n   WHERE q3c_radial_query(ra, dec, 189.58, -40.89, 0.5) AND\n         mag_auto_g BETWEEN 14 AND 25 AND\n         (mag_auto_g - mag_auto_r) BETWEEN -0.4 AND 0.4\"\"\".format(ra, dec)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 42,
                "codebleu": {
                    "codebleu": 0.34411549548643916,
                    "ngram_match_score": 0.28372131444393245,
                    "weighted_ngram_match_score": 0.3768315765927333,
                    "syntax_match_score": 0.09090909090909091,
                    "dataflow_match_score": 0.625
                },
                "codebertscore": {
                    "precision": 0.8889023065567017,
                    "recall": 0.9057796597480774,
                    "F1": 0.8972615599632263,
                    "F3": 0.9040631055831909
                },
                "codebertscore_rescaled": {
                    "precision": 0.7778046131134033,
                    "recall": 0.8115593194961548,
                    "F1": 0.7945231199264526,
                    "F3": 0.8081262111663818
                }
            },
            {
                "ind": 12,
                "gen_code": "# Perform the query and store the result in a DataFrame\nR = qc.query(sql=query, fmt='pandas')",
                "true_code": "%time\nR = qc.query(sql=query,fmt='pandas') # R is a pandas DataFrame",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 51,
                "codebleu": {
                    "codebleu": 0.4535039100606729,
                    "ngram_match_score": 0.03514847831369806,
                    "weighted_ngram_match_score": 0.05159443465626647,
                    "syntax_match_score": 0.7272727272727273,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.8727548122406006,
                    "recall": 0.9099599719047546,
                    "F1": 0.8909690976142883,
                    "F3": 0.9060973525047302
                },
                "codebertscore_rescaled": {
                    "precision": 0.7455096244812012,
                    "recall": 0.8199199438095093,
                    "F1": 0.7819381952285767,
                    "F3": 0.8121947050094604
                }
            },
            {
                "ind": 14,
                "gen_code": "# Print the number of objects in the DataFrame\nprint(f\"Number of objects retrieved: {len(R)}\")\n\n# Display the first few rows of the DataFrame\nR.head()",
                "true_code": "print(\"Number of objects:\", R.shape[0])\nprint(R.head())",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 38,
                "codebleu": {
                    "codebleu": 0.3423335128887268,
                    "ngram_match_score": 0.007913247271422612,
                    "weighted_ngram_match_score": 0.05372849659117709,
                    "syntax_match_score": 0.3076923076923077,
                    "dataflow_match_score": 0.0
                },
                "codebertscore": {
                    "precision": 0.7866294384002686,
                    "recall": 0.884597897529602,
                    "F1": 0.8327421545982361,
                    "F3": 0.8737164735794067
                },
                "codebertscore_rescaled": {
                    "precision": 0.5732588768005371,
                    "recall": 0.7691957950592041,
                    "F1": 0.6654843091964722,
                    "F3": 0.7474329471588135
                }
            },
            {
                "ind": 16,
                "gen_code": "plt.figure(figsize=(10, 8))\nhb = plt.hexbin(R['ra'], R['dec'], gridsize=100, cmap='Blues', mincnt=1)\nplt.xlabel('RA')\nplt.ylabel('Dec')\nplt.title('Spatial Density of Blue Stars')\ncb = plt.colorbar(hb)\ncb.set_label('Number of objects per spatial bin')\nplt.show()",
                "true_code": "fig = plt.figure(figsize=(7,6))\nplt.hexbin(R['ra'], R['dec'],gridsize=200)\nplt.xlabel('RA')\nplt.ylabel('Dec')\nplt.colorbar(label='number of objects per spatial bin');",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 59,
                "codebleu": {
                    "codebleu": 0.4808242414781908,
                    "ngram_match_score": 0.11556647985416685,
                    "weighted_ngram_match_score": 0.24712442545253582,
                    "syntax_match_score": 0.7272727272727273,
                    "dataflow_match_score": 0.8333333333333334
                },
                "codebertscore": {
                    "precision": 0.8612820506095886,
                    "recall": 0.9454625844955444,
                    "F1": 0.901411235332489,
                    "F3": 0.9363113045692444
                },
                "codebertscore_rescaled": {
                    "precision": 0.7225641012191772,
                    "recall": 0.8909251689910889,
                    "F1": 0.802822470664978,
                    "F3": 0.8726226091384888
                }
            },
            {
                "ind": 18,
                "gen_code": "def dwarf_filter(ra, dec, fwhm_small=2.5/60., fwhm_big=10./60., nbins=512):\n    \"\"\" Convolve a density field with two different Gaussians and return some measures\n    \"\"\"\n\n    # using pixelscale (arcmin -> degrees)\n    pixelscale = 0.5/60. \n\n    # Compute boundaries in RA and Dec\n    ra_min, ra_max = np.min(ra), np.max(ra)\n    dec_min, dec_max = np.min(dec), np.max(dec)\n\n    # Create 2D histogram of ra, dec density\n    hist_raw, xedges, yedges = np.histogram2d(ra, dec, bins=nbins, range=[[ra_min, ra_max], [dec_min, dec_max]])\n\n    # Create 2D Gaussian kernels\n    gauss_small = convolution.Gaussian2DKernel(fwhm_small / pixelscale)\n    gauss_big = convolution.Gaussian2DKernel(fwhm_big / pixelscale)\n\n    # Convolve with Gaussian kernels\n    conv_small = convolution.convolve(hist_raw, gauss_small)\n    conv_big = convolution.convolve(hist_raw, gauss_big)\n\n    # Calculate difference\n    diff = conv_small - conv_big\n\n    # Flatten histogram for statistics\n    diff_flat = diff.flatten()\n    mean = np.mean(diff_flat)\n    std = np.std(diff_flat)\n\n    return hist_raw, conv_small, conv_big, diff, mean, std\n",
                "true_code": "def dwarf_filter (ra,dec,fwhm_small=2.0,fwhm_big=20):\n\n    \"\"\"Differential convolution with 2D Gaussian kernels.\n    \n       Based on Koposov et al. (2008).\n       Code by Ken Mighell and Mike Fitzpatrick.\n       Minor edits by RN.\n       \n       Parameters\n       ----------\n       ra, dec : float or array\n           RA & Dec in degrees.\n    \n       fwhm_small, fwhm_big : float\n           Full-width half maximum sizes of the small and big Gaussian kernels\n           to use in convolution, in arcminutes.\n    \"\"\"\n    \n    x, y = ra, dec\n\n    print(\"Computing differential convolution .... \",)\n\n    # Information about declination (y) [degrees]\n    ymean = (y.min() + y.max()) / 2.0\n    ydiff_arcmin = (y.max() - y.min()) * 60.0 # convert from degrees to arcmin\n\n    # Information about right ascension (x) [degrees in time]:\n    xdiff = x.max() - x.min() # angular separation [degrees (time)] \n    xmean = (x.min() + x.max()) / 2.0\n\n    # convert from degrees in time to separation in angular degrees:\n    xdiff_angular = (x.max() - x.min()) * np.cos(ymean*(np.pi/180.0))\n\n    # convert from degress to arcmin\n    xdiff_angular_arcmin = xdiff_angular * 60.0 \n\n    # Get the number of one-arcmin pixels in the X and Y directions:\n    nx = np.rint(xdiff_angular_arcmin).astype('int')\n    ny = np.rint(ydiff_arcmin).astype('int')\n\n    # Create a two-dimensional histogram of the raw counts:\n    Counts, xedges, yedges  = np.histogram2d (x, y, (nx,ny) )\n    extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]\n    raw_hist = np.rot90(Counts).copy() # hack around Pythonic weirdness\n\n    # Make the small and big Gaussian kernels with a standard deviation\n    # of the given FWHM in arcmin^2 pixels.\n    kernel_small = convolution.Gaussian2DKernel(fwhm_small/2.35,factor=1)\n    kernel_big = convolution.Gaussian2DKernel(fwhm_big/2.35,factor=1)\n\n    # Compute the differential convolution kernels.\n    conv_big = convolution.convolve(raw_hist, kernel_big)\n    conv_small = convolution.convolve(raw_hist, kernel_small)\n    conv_delta = conv_small - conv_big\n    delta = conv_delta.copy()\n\n    # Compute statistics and the floor\n    mean = np.mean(delta, dtype='float64')\n    sigma = np.std(delta, dtype='float64')\n    sigmaRaw = np.std(raw_hist,dtype='float64')\n    median = np.median(delta) # not used\n    floor = mean\n\n    print('dwarf_filter: mean = {:g}  sigma = {:g} sigmaRaw = {:g}'.format(mean, sigma, sigmaRaw))\n\n    clipped = delta.copy()\n    clipped[delta < floor] = floor\n\n    # Return the computed fields.\n    return raw_hist, extent, delta, clipped, sigma",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 12,
                "codebleu": {
                    "codebleu": 0.16161639188889954,
                    "ngram_match_score": 0.01256650524628007,
                    "weighted_ngram_match_score": 0.02373350708553651,
                    "syntax_match_score": 0.4010152284263959,
                    "dataflow_match_score": 0.20915032679738563
                },
                "codebertscore": {
                    "precision": 0.8480896949768066,
                    "recall": 0.7534388899803162,
                    "F1": 0.7979673743247986,
                    "F3": 0.7619425654411316
                },
                "codebertscore_rescaled": {
                    "precision": 0.6961793899536133,
                    "recall": 0.5068777799606323,
                    "F1": 0.5959347486495972,
                    "F3": 0.5238851308822632
                }
            },
            {
                "ind": 20,
                "gen_code": "(raw_hist, extent, delta, clipped, sigma) = dwarf_filter(R['ra'].values, R['dec'].values)",
                "true_code": "%time\nsmall_k, big_k = 2., 20.  # kernel sizes in arcminutes\nraw, extent, delta, clipped, dsigma = dwarf_filter(R['ra'],R['dec'],fwhm_small=small_k,fwhm_big=big_k)",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 56,
                "codebleu": {
                    "codebleu": 0.1492404852514745,
                    "ngram_match_score": 0.042323061349259145,
                    "weighted_ngram_match_score": 0.05463887965663884,
                    "syntax_match_score": 0.2222222222222222,
                    "dataflow_match_score": 0.2777777777777778
                },
                "codebertscore": {
                    "precision": 0.8827557563781738,
                    "recall": 0.7416027188301086,
                    "F1": 0.8060463666915894,
                    "F3": 0.7536537051200867
                },
                "codebertscore_rescaled": {
                    "precision": 0.7655115127563477,
                    "recall": 0.4832054376602173,
                    "F1": 0.6120927333831787,
                    "F3": 0.5073074102401733
                }
            },
            {
                "ind": 22,
                "gen_code": "plt.figure(figsize=(7,6))\nplt.imshow(delta.T, extent=extent, interpolation='none', origin='lower', cmap='viridis')\nplt.colorbar(fraction=0.04).set_label('relative spatial density')\nplt.title('Convolved 2D Histogram')\nplt.xlabel('RA')\nplt.ylabel('Dec')\nplt.show()",
                "true_code": "fig, ax = plt.subplots(figsize=(7,6))\nim = plt.imshow(clipped)\nplt.xlabel('pixel')\nplt.ylabel('pixel')\nplt.colorbar(label='relative spatial density after convolution');",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 6,
                "codebleu": {
                    "codebleu": 0.2723515855274496,
                    "ngram_match_score": 0.013217947626377298,
                    "weighted_ngram_match_score": 0.01428363257865929,
                    "syntax_match_score": 0.6333333333333333,
                    "dataflow_match_score": 0.42857142857142855
                },
                "codebertscore": {
                    "precision": 0.8155868649482727,
                    "recall": 0.875321626663208,
                    "F1": 0.8443991541862488,
                    "F3": 0.8689572215080261
                },
                "codebertscore_rescaled": {
                    "precision": 0.6311737298965454,
                    "recall": 0.750643253326416,
                    "F1": 0.6887983083724976,
                    "F3": 0.7379144430160522
                }
            },
            {
                "ind": 25,
                "gen_code": "from photutils.detection import find_peaks\nfrom astropy.stats import sigma_clipped_stats\n\n# Threshold for peak detection\nthreshold = 3.0 * dsigma\n\n# Identify peaks that are at least 3-sigma above the mean level\npeaks_tbl = find_peaks(clipped, threshold, box_size=5)\n\n# Convert pixel positions to RA and Dec\nx_peak_pix, y_peak_pix = peaks_tbl['x_peak'], peaks_tbl['y_peak']\nx_peak_world = xedges[x_peak_pix + 0.5]  # Convert from pixel to RA\ny_peak_world = yedges[y_peak_pix + 0.5]  # Convert from pixel to Dec\n\n# Combine the peaks' coordinates\npeaks = list(zip(x_peak_world, y_peak_world))\n\n# Print the results\nprint(\"Detected peaks (RA, Dec):\")\nfor ra, dec in peaks:\n    print(f\"RA: {ra:.2f}, Dec: {dec:.2f}\")",
                "true_code": "# find peaks\nmean, median, std = stats.sigma_clipped_stats(clipped,sigma=3.0,maxiters=5)\nprint(mean, median, std)\ntbl = find_peaks(clipped,median+3,box_size=small_k*2)\n\n# add ra & dec positions of peaks found\na, b = extent[:2]\nxvec = np.arange(a,b,(b-a)/clipped.shape[1])\na, b = extent[2:]\nyvec = np.arange(a,b,(b-a)/clipped.shape[0])\n\ntbl['ra'] = xvec[tbl['x_peak']]\ntbl['dec'] = yvec[-tbl['y_peak']-1]\nprint(tbl)",
                "error_ind": 25,
                "direct_match": false,
                "fuzzy_match": 8,
                "codebleu": {
                    "codebleu": 0.11072473717869316,
                    "ngram_match_score": 0.0035026270829233708,
                    "weighted_ngram_match_score": 0.007790345908226496,
                    "syntax_match_score": 0.16176470588235295,
                    "dataflow_match_score": 0.2698412698412698
                },
                "codebertscore": {
                    "precision": 0.7689675092697144,
                    "recall": 0.7846341133117676,
                    "F1": 0.7767218351364136,
                    "F3": 0.7830387949943542
                },
                "codebertscore_rescaled": {
                    "precision": 0.5379350185394287,
                    "recall": 0.5692682266235352,
                    "F1": 0.5534436702728271,
                    "F3": 0.5660775899887085
                }
            },
            {
                "ind": 27,
                "gen_code": "fig, ax = plt.subplots(figsize=(7,6))\nim = ax.imshow(clipped, extent=extent, origin='lower')\nax.scatter(tbl['ra'], tbl['dec'], s=tbl['peak_value']*10, facecolor='none', edgecolor='k')\nplt.xlabel('RA')\nplt.ylabel('Dec')\nplt.colorbar(im, label='relative spatial density after convolution')\nplt.title('Identified Density Peaks')\nplt.show()",
                "true_code": "ecs = ['w'] # color of box frame\nax.scatter(tbl['x_peak'],tbl['y_peak'],marker='s',s=tbl['peak_value']*50,c='none',edgecolors=ecs,lw=3) # keeps writing to previous ax\nfig  # repeats (the updated) figure",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 16,
                "codebleu": {
                    "codebleu": 0.20279249950559802,
                    "ngram_match_score": 0.008640609739997756,
                    "weighted_ngram_match_score": 0.010862721615727716,
                    "syntax_match_score": 0.625,
                    "dataflow_match_score": 0.16666666666666666
                },
                "codebertscore": {
                    "precision": 0.7526781558990479,
                    "recall": 0.779530942440033,
                    "F1": 0.7658692002296448,
                    "F3": 0.7767597436904907
                },
                "codebertscore_rescaled": {
                    "precision": 0.5053563117980957,
                    "recall": 0.5590618848800659,
                    "F1": 0.5317384004592896,
                    "F3": 0.5535194873809814
                }
            },
            {
                "ind": 29,
                "gen_code": "# Step 1: Set up the SIA service\nsvc_nsa = sia.SIAService(\"https://datalab.noirlab.edu/sia/nsa\")\n\n# Step 2: Define RA, Dec, and FoV\nra = 189.58\ndec = -40.89\nfov = 0.1 # degrees\n\n# Step 3: Retrieve image cutouts\nimages_nsa = svc_nsa.search((ra, dec), fov, verbosity=2)\n\n\n# Step 4: Define the function to plot the images\ndef plot_images(images, geo=None, panel_size=(6, 6), titles=None, cmap='gray'):\n    \"\"\"\n    Plot images side-by-side.\n    \n    Parameters:\n    - images: list of 2D arrays representing the images.\n    - geo: (optional) tuple (rows, cols) geometry of the plot grid. If None, defaults to (len(images), 1).\n    - panel_size: tuple, size of each panel (subplot).\n    - titles: list of strings for titles for each image.\n    - cmap: colormap for image visualization.\n    \"\"\"\n    if geo is None:\n        geo = (len(images), 1)\n    \n    fig, axes = plt.subplots(geo[0], geo[1], figsize=(panel_size[0] * geo[1], panel_size[1] * geo[0]))\n    axes = np.atleast_1d(axes).flatten()  # Flatten in case the layout is hierarchical (2D array of axes)\n\n    for i, (ax, img) in enumerate(zip(axes, images)):\n        im = ax.imshow(img, cmap=cmap, origin='lower')\n        if titles is not None and i < len(titles):\n            ax.set_title(titles[i])\n        fig.colorbar(im, ax=ax, orientation='vertical')\n\n    plt.tight_layout()\n    plt.show()\n\n\n# Demonstration of the function with mock images\n# (Since actual image downloads aren't shown here in detail)\n\n# Let's pretend we have some images already downloaded or generated:\n# Mock images would be created as random arrays for demonstration purposes:\nmock_images = [np.random.random((100, 100)) for _ in range(3)]  # 3 random mock images\n\n# Plot them using our function\nplot_images(mock_images, geo=(1, 3), panel_size=(4, 4), titles=['Cutout 1', 'Cutout 2', 'Cutout 3'])",
                "true_code": "# set up SIA and image table\nDEF_ACCESS_URL = \"https://datalab.noirlab.edu/sia/nsa\"\nsvc_nsa = sia.SIAService(DEF_ACCESS_URL)\nra = 189.58\ndec = -40.89\nfov = 0.1\n\nimgTable = svc_nsa.search((ra,dec), (fov/np.cos(dec*np.pi/180), fov), verbosity=2).to_table()\n   \n# multi panel image plotter\ndef plot_images(images,geo=None,panelsize=5,titles=list('gri'),cmap=plt.cm.gray_r):\n    if geo is None:\n        geo = (len(images),1)  # ncols, nrows\n        \n    fig = plt.figure(figsize=(geo[0]*panelsize,geo[1]*panelsize))\n    for j,img in enumerate(images):\n        ax = fig.add_subplot(geo[1],geo[0],j+1)\n        ax.imshow(img,origin='lower',interpolation='none',cmap=cmap,norm=plt.mpl.colors.PowerNorm(0.1))\n        ax.set_title('{:s}'.format(titles[j]))\n        plt.axis('off')",
                "error_ind": null,
                "direct_match": false,
                "fuzzy_match": 11,
                "codebleu": {
                    "codebleu": 0.3062685519865945,
                    "ngram_match_score": 0.05956927298511497,
                    "weighted_ngram_match_score": 0.27217589854489177,
                    "syntax_match_score": 0.514018691588785,
                    "dataflow_match_score": 0.3793103448275862
                },
                "codebertscore": {
                    "precision": 0.7721536159515381,
                    "recall": 0.8494348526000977,
                    "F1": 0.8089527487754822,
                    "F3": 0.841017484664917
                },
                "codebertscore_rescaled": {
                    "precision": 0.5443072319030762,
                    "recall": 0.6988697052001953,
                    "F1": 0.6179054975509644,
                    "F3": 0.682034969329834
                }
            },
            {
                "ind": 31,
                "gen_code": "def get_images(image_table, ra, dec, fov, bands=['g','r','i']):\n    images = []\n    for band in bands:\n        # Select image for the desired band\n        sel = (image_table['obs_bandpass'] == band) & (image_table['s_ra'] == ra) & (image_table['s_dec'] == dec)\n        img_url = image_table['access_url'][sel][0]\n        \n        # Download image data\n        img_file = download_file(img_url, cache=True)\n        hdulist = fits.open(img_file)\n        \n        # Get image data and normalize by exposure time and zeropoint\n        img_data = hdulist[0].data * 10**(hdulist[0].header['MAGZERO']/-2.5) / hdulist[0].header['EXPTIME']\n        \n        # Apply astrometric offsets to align images\n        a, b = 50, 50  # assuming some offsets; adjust as necessary\n        img_cropped = img_data[a:a+500, b:b+500]  # crop the central region\n        img_aligned = img_cropped - np.median(img_cropped)\n        \n        images.append(img_aligned)\n        hdulist.close()\n\n    return images\n\n# Fetch and plot images for g, r, i bands\nimages = get_images(imgTable, ra=ra, dec=dec, fov=fov)\nplot_images(images, geo=(1,3), panelsize=5, titles=['g band', 'r band', 'i band'], cmap='gray')",
                "true_code": "sel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize'].astype(str)=='311551') & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'g'))\n#print(imgTable[sel][0])\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni1 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n#Dimensions of each image need to be equal\nimage1 = i1[0:1362, b:1233]\n#Normalization\n#image1 *= (10.0**(0.4*(30.0 - zpt)))/exptime\n#from header, exptime=85, expnum=188187, ccdnum=16\nzp=31.514652\nimage1 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 3,
                "codebleu": {
                    "codebleu": 0.20651770037268213,
                    "ngram_match_score": 0.0050761993383782985,
                    "weighted_ngram_match_score": 0.010275470537696329,
                    "syntax_match_score": 0.3181818181818182,
                    "dataflow_match_score": 0.4925373134328358
                },
                "codebertscore": {
                    "precision": 0.7425846457481384,
                    "recall": 0.7517382502555847,
                    "F1": 0.7471333742141724,
                    "F3": 0.7508127689361572
                },
                "codebertscore_rescaled": {
                    "precision": 0.48516929149627686,
                    "recall": 0.5034765005111694,
                    "F1": 0.4942667484283447,
                    "F3": 0.5016255378723145
                }
            },
            {
                "ind": 32,
                "gen_code": "sel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize']>300000) & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'r'))\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni2 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n# Apply geometric offset to align images\nb = 200  # arbitrary offset\nimage2 = i2[b:b+1362, :1233]\n# Normalization\nzp=31.302973\nimage2 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]\n\n#Repeat the similar blocks for the 'i' band\nsel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize']>300000) & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'i'))\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni3 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n# Apply geometric offset to align images\nimage3 = i3[b:b+1362, :1233]\n# Normalization\nzp=30.931051\nimage3 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]\n\n#plot using the plot_images function\nplot_images([image1,image2,image3],cmap=plt.cm.gray_r)",
                "true_code": "sel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize'].astype(str)=='313152') & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'r')) \n#print(imgTable[sel][0])\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni2 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n#Dimensions of each image need to be equal\nimage2 = i2[0:1362, 0:1233-b]\n#Normalization\n#image2 *= (10.0**(0.4*(30.0 - zpt)))/exptime\n#from header, exptime=85, expnum=188186, ccdnum=16\nzp=31.66765\nimage2 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 49,
                "codebleu": {
                    "codebleu": 0.636313735913576,
                    "ngram_match_score": 0.2628458628453108,
                    "weighted_ngram_match_score": 0.5236516452505002,
                    "syntax_match_score": 0.8764044943820225,
                    "dataflow_match_score": 0.8823529411764706
                },
                "codebertscore": {
                    "precision": 0.8773154020309448,
                    "recall": 0.9003778696060181,
                    "F1": 0.8886970281600952,
                    "F3": 0.898017168045044
                },
                "codebertscore_rescaled": {
                    "precision": 0.7546308040618896,
                    "recall": 0.8007557392120361,
                    "F1": 0.7773940563201904,
                    "F3": 0.7960343360900879
                }
            },
            {
                "ind": 33,
                "gen_code": "sel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize'].astype(str)=='313152') & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'i')) \n#print(imgTable[sel][0])\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni3 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n# Dimensions of each image need to be equal\nimage3 = i3[0:1362, 0:1233]\n# Normalization\n# image3 *= (10.0**(0.4*(30.0 - zpt)))/exptime\n# from header, exptime=85, expnum=188188, ccdnum=16\nzp=32.045168\nimage3 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]\n\n# Plot images\nplot_images([image1, image2, image3], geo=(1, 3), titles=['g', 'r', 'i'])\n",
                "true_code": "sel = (imgTable['proctype'].astype(str)=='InstCal') & (imgTable['prodtype'].astype(str)=='image') & (imgTable['access_estsize'].astype(str)=='307960') & \\\n    (startswith(imgTable['obs_bandpass'].astype(str),'i'))\n#print(imgTable[sel][0])\n\nrow = imgTable[sel][0]\nurl = row['access_url'] # get the download URL\nfilename = download_file(url,cache=True,show_progress=False,timeout=120)\nhdu = fits.open(filename)[0]\ni3 = hdu.data\nhdr = hdu.header\nwcs = WCS(hdr)\n#Dimensions of each image need to be equal\nimage3 = i3[0:1362, b:1233]\n#Normalization\n#image3 *= (10.0**(0.4*(30.0 - zpt)))/exptime\n#from header, exptime=20, expnum=294524, ccdnum=60\n#Note: the expnum and ccdnum for the i image did not produce a zeropoint, \n#so we estimated a zeropoint of 31.0, which worked well to produce a proper false-color image.\nzp=31.0\nimage3 *= (10.0**(0.4*(30.0-zp)))/hdr[\"EXPTIME\"]",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 79,
                "codebleu": {
                    "codebleu": 0.6997094596218775,
                    "ngram_match_score": 0.4841771412907963,
                    "weighted_ngram_match_score": 0.47595649095519393,
                    "syntax_match_score": 0.9431818181818182,
                    "dataflow_match_score": 0.8955223880597015
                },
                "codebertscore": {
                    "precision": 0.9554466009140015,
                    "recall": 0.9255608916282654,
                    "F1": 0.9402663707733154,
                    "F3": 0.9284651875495911
                },
                "codebertscore_rescaled": {
                    "precision": 0.9108932018280029,
                    "recall": 0.8511217832565308,
                    "F1": 0.8805327415466309,
                    "F3": 0.8569303750991821
                }
            },
            {
                "ind": 35,
                "gen_code": "# Stack the images to create a false-color composite \nrgb_default = make_lupton_rgb(image1, image2, image3, Q=10, stretch=0.5)\n\n# Plot rgb image\nfig, ax = plt.subplots(figsize=(6,6))\nax.imshow(rgb_default, origin='lower')\nax.set_title('False-color 3-band Image')\nplt.axis('off')\n\n# Plot the individual g, r, i band images alongside for comparison\nplot_images([image1, image2, image3], geo=(1,3), panelsize=5, titles=list('gri'))",
                "true_code": "bands = list('gri')\nimages=[image1, image2, image3]\nimages = [im-np.median(im) for im in images] # subtract median from all images for better scaling\nimages += [make_lupton_rgb(*images[::-1],stretch=1)] # add a 3-color composite image\nplot_images(images,geo=(4,1),titles=bands+['False-color 3-band image'])",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 7,
                "codebleu": {
                    "codebleu": 0.16903850605816362,
                    "ngram_match_score": 0.007119802576104629,
                    "weighted_ngram_match_score": 0.009943312565640667,
                    "syntax_match_score": 0.25,
                    "dataflow_match_score": 0.4090909090909091
                },
                "codebertscore": {
                    "precision": 0.7958235144615173,
                    "recall": 0.8083477020263672,
                    "F1": 0.8020366430282593,
                    "F3": 0.8070775866508484
                },
                "codebertscore_rescaled": {
                    "precision": 0.5916470289230347,
                    "recall": 0.6166954040527344,
                    "F1": 0.6040732860565186,
                    "F3": 0.6141551733016968
                }
            },
            {
                "ind": 37,
                "gen_code": "def makequery(ra, dec, radius=0.05):\n    \"\"\"Construct SQL query for selecting stars around a given position.\n    \n    Parameters\n    ----------\n    ra, dec : float\n        Right Ascension and Declination in degrees.\n    radius : float\n        Radius for the selection query in degrees (default is 0.05).\n\n    Returns\n    -------\n    query : str\n        SQL query string.\n    \"\"\"\n    query = f\"\"\"\n    SELECT ra, dec, mag_auto_g, mag_auto_r, mag_auto_i\n    FROM delve_dr2.objects\n    WHERE q3c_radial_query(ra, dec, {ra}, {dec}, {radius})\n          AND mag_auto_g BETWEEN 14 AND 25\n    \"\"\"\n    return query",
                "true_code": "def makequery(ra0,dec0,radius0):\n    query_template = \"\"\"\nSELECT ra,dec,mag_auto_g,mag_auto_r,mag_auto_i FROM delve_dr2.objects\n  WHERE q3c_radial_query(ra, dec, {0}, {1}, {2})\n    AND mag_auto_g BETWEEN 14 AND 25\"\"\" \n    query = query_template.format(ra0,dec0,radius0)\n    \n    return query",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 40,
                "codebleu": {
                    "codebleu": 0.17252941349128184,
                    "ngram_match_score": 0.11025002192897533,
                    "weighted_ngram_match_score": 0.3362778884464085,
                    "syntax_match_score": 0.07692307692307693,
                    "dataflow_match_score": 0.16666666666666666
                },
                "codebertscore": {
                    "precision": 0.8045395612716675,
                    "recall": 0.8645550012588501,
                    "F1": 0.8334682583808899,
                    "F3": 0.8581534624099731
                },
                "codebertscore_rescaled": {
                    "precision": 0.609079122543335,
                    "recall": 0.7291100025177002,
                    "F1": 0.6669365167617798,
                    "F3": 0.7163069248199463
                }
            },
            {
                "ind": 39,
                "gen_code": "ra_peak, dec_peak = tbl['ra'][0], tbl['dec'][0]\nradius = 5/60.0  # convert arcminutes to degrees\n\nquery_peak = makequery(ra_peak, dec_peak, radius)\nR0 = qc.query(sql=query_peak, fmt='pandas')\n\nprint(R0.head())",
                "true_code": "query0 = makequery(tbl['ra'][0],tbl['dec'][0], 5./60.) # center ra & dec\nR0 = qc.query(sql=query0,fmt='pandas')\nprint(R0.head()) # a pandas method",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 51,
                "codebleu": {
                    "codebleu": 0.31657165802159515,
                    "ngram_match_score": 0.022023814946586635,
                    "weighted_ngram_match_score": 0.03058760346458022,
                    "syntax_match_score": 0.7692307692307693,
                    "dataflow_match_score": 0.4444444444444444
                },
                "codebertscore": {
                    "precision": 0.8692604303359985,
                    "recall": 0.9004324674606323,
                    "F1": 0.88457190990448,
                    "F3": 0.8972150683403015
                },
                "codebertscore_rescaled": {
                    "precision": 0.7385208606719971,
                    "recall": 0.8008649349212646,
                    "F1": 0.76914381980896,
                    "F3": 0.794430136680603
                }
            },
            {
                "ind": 41,
                "gen_code": "# Compute the color index g-r\nR0['g_r'] = R0['mag_auto_g'] - R0['mag_auto_r']\n\n# Display the first few rows of the DataFrame to verify the addition of the new column\nprint(R0.head())",
                "true_code": "R0['g_r'] = R0['mag_auto_g'] - R0['mag_auto_r']\nprint( R0.head())",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 52,
                "codebleu": {
                    "codebleu": 0.683810593686486,
                    "ngram_match_score": 0.12045422179467957,
                    "weighted_ngram_match_score": 0.6147881529512643,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.7881144881248474,
                    "recall": 0.9458232522010803,
                    "F1": 0.8597967028617859,
                    "F3": 0.9272677898406982
                },
                "codebertscore_rescaled": {
                    "precision": 0.5762289762496948,
                    "recall": 0.8916465044021606,
                    "F1": 0.7195934057235718,
                    "F3": 0.8545355796813965
                }
            },
            {
                "ind": 43,
                "gen_code": "def plotpanel(ax, Q, title=\"Color-Magnitude Diagram\"):\n    ax.scatter(Q['g_r'], Q['mag_auto_g'], s=1, c='b', alpha=0.5)\n    ax.set_xlim([-1, 2])\n    ax.set_ylim([25, 14])\n    ax.set_xlabel(\"$g-r$\")\n    ax.set_ylabel(\"$g$\")\n    ax.set_title(f\"{title}\\nObjects: {len(Q)}\")\n\nfig, ax = plt.subplots(figsize=(6,6))\nplotpanel(ax, R0, title='Stars near the Density Peak')\nplt.show()",
                "true_code": "def plotpanel(axid,x,y,title='',xlim=(-1,2),ylim=(25.2,14)):\n    ax = fig.add_subplot(axid)\n    ax.scatter(x,y,marker='.',s=10, alpha=0.8)\n    ax.set_xlabel(x.name)\n    ax.set_ylabel(y.name)\n    ax.set_xlim(xlim)\n    ax.set_ylim(ylim)\n    ax.set_title(title)",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 14,
                "codebleu": {
                    "codebleu": 0.2379419992794137,
                    "ngram_match_score": 0.014614031921776127,
                    "weighted_ngram_match_score": 0.045849617369791706,
                    "syntax_match_score": 0.391304347826087,
                    "dataflow_match_score": 0.5
                },
                "codebertscore": {
                    "precision": 0.7826492786407471,
                    "recall": 0.8655457496643066,
                    "F1": 0.8220129013061523,
                    "F3": 0.8564742207527161
                },
                "codebertscore_rescaled": {
                    "precision": 0.5652985572814941,
                    "recall": 0.7310914993286133,
                    "F1": 0.6440258026123047,
                    "F3": 0.7129484415054321
                }
            },
            {
                "ind": 44,
                "gen_code": "fig = plt.figure(figsize=(7,7))\nobject_count = R0.shape[0]\nplotpanel(111, R0['g_r'], R0['mag_auto_g'], title='Color-Magnitude Diagram\\nNumber of Objects: {}'.format(object_count))\nplt.tight_layout()\nplt.show()",
                "true_code": "fig = plt.figure(figsize=(12,5.5))\nplotpanel(121,R0['g_r'],R0['mag_auto_g'],'white box, {:d} objects'.format(len(R0)))",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 35,
                "codebleu": {
                    "codebleu": 0.24618877346468193,
                    "ngram_match_score": 0.026012784404037925,
                    "weighted_ngram_match_score": 0.06985342056580097,
                    "syntax_match_score": 0.3333333333333333,
                    "dataflow_match_score": 0.5555555555555556
                },
                "codebertscore": {
                    "precision": 0.8568078875541687,
                    "recall": 0.9149630665779114,
                    "F1": 0.8849310874938965,
                    "F3": 0.9087947010993958
                },
                "codebertscore_rescaled": {
                    "precision": 0.7136157751083374,
                    "recall": 0.8299261331558228,
                    "F1": 0.769862174987793,
                    "F3": 0.8175894021987915
                }
            },
            {
                "ind": 47,
                "gen_code": "outfile = 'cen1.csv'\nR0.to_csv(outfile, index=False)",
                "true_code": "outfile = 'cen1.csv'\nR0.to_csv(outfile,index=False)",
                "error_ind": 31,
                "direct_match": false,
                "fuzzy_match": 99,
                "codebleu": {
                    "codebleu": 0.6604937760389722,
                    "ngram_match_score": 0.26591479484724945,
                    "weighted_ngram_match_score": 0.37606030930863943,
                    "syntax_match_score": 1.0,
                    "dataflow_match_score": 1.0
                },
                "codebertscore": {
                    "precision": 0.9974263906478882,
                    "recall": 0.9974263906478882,
                    "F1": 0.9974263906478882,
                    "F3": 0.997426450252533
                },
                "codebertscore_rescaled": {
                    "precision": 0.9948527812957764,
                    "recall": 0.9948527812957764,
                    "F1": 0.9948527812957764,
                    "F3": 0.9948529005050659
                }
            }
        ],
        "result_summary": {
            "direct_match": 0.0,
            "fuzzy_match": 35.0,
            "codebleu": 0.34738814281165264,
            "syntax_match_score": 0.5313587798509236,
            "codebertscore": 0.8462325703530085,
            "codebertscore_rescaled": 0.692465140706017,
            "code_success": 0.47619047619047616,
            "total_code_cell_count": 21
        }
    }
]
